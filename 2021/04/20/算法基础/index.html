<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rockcohen.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="What I’m doing right now，I’m chasing perfection">
<meta property="og:type" content="article">
<meta property="og:title" content="递归-分治-动态规划-贪心">
<meta property="og:url" content="https://rockcohen.github.io/2021/04/20/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Rock Cohen">
<meta property="og:description" content="What I’m doing right now，I’m chasing perfection">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rockcohen.github.io/2021/04/20/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%A7%91%E6%AF%94.PNG">
<meta property="og:image" content="https://rockcohen.github.io/2021/04/20/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E9%92%A2%E6%9D%A1%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98.PNG">
<meta property="og:image" content="https://rockcohen.github.io/2021/04/20/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E9%92%A2%E6%9D%A1%E6%9C%80%E4%BC%98%E8%A7%A3%E5%88%BB%E7%94%BB.PNG">
<meta property="og:image" content="https://rockcohen.github.io/2021/04/20/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E9%92%A2%E6%9D%A1%E6%9C%80%E4%BC%98%E8%A7%A3%E5%88%BB%E7%94%BB%E4%BA%8C.PNG">
<meta property="article:published_time" content="2021-04-20T02:51:08.000Z">
<meta property="article:modified_time" content="2021-04-22T08:52:44.000Z">
<meta property="article:author" content="RockCohen">
<meta property="article:tag" content="Algorithm">
<meta property="article:tag" content="Dynamic Programming">
<meta property="article:tag" content="Divide Conquer">
<meta property="article:tag" content="Greedy">
<meta property="article:tag" content="Recursion">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rockcohen.github.io/2021/04/20/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%A7%91%E6%AF%94.PNG">

<link rel="canonical" href="https://rockcohen.github.io/2021/04/20/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>递归-分治-动态规划-贪心 | Rock Cohen</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Rock Cohen</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Cohen</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rockcohen.github.io/2021/04/20/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/hugo.png">
      <meta itemprop="name" content="RockCohen">
      <meta itemprop="description" content="a programmer">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock Cohen">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          递归-分治-动态规划-贪心
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-20 10:51:08" itemprop="dateCreated datePublished" datetime="2021-04-20T10:51:08+08:00">2021-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-22 16:52:44" itemprop="dateModified" datetime="2021-04-22T16:52:44+08:00">2021-04-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <img src="/2021/04/20/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E7%A7%91%E6%AF%94.PNG" class>

<h1 id="What-I’m-doing-right-now，I’m-chasing-perfection"><a href="#What-I’m-doing-right-now，I’m-chasing-perfection" class="headerlink" title="What I’m doing right now，I’m chasing perfection"></a>What I’m doing right now，I’m chasing perfection</h1><span id="more"></span>

<p>力扣题解：<a target="_blank" rel="noopener" href="https://gitee.com/rockcohen/leetcode">https://gitee.com/rockcohen/leetcode</a></p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归的核心在于调用本身去求解子问题。直到子问题无需使用递归的方式来求解。<br>递归的属性：</p>
<ol>
<li>一个简单的基本案例，无需使用递归来解决的子问题，也就是递归的出口。</li>
<li>一组规则，地推关系，可将所有的问题推到基本案例。递推关系：一个问题的结果与其子问题的结果之间的关系。</li>
</ol>
<p><strong>基本问题</strong>：不需要进一步的递归调用就可以直接计算答案的情况。有时，基本案例也被称为 bottom cases，因为它们往往是问题被减少到最小规模的情况，也就是如果我们认为将问题划分为子问题是一种自上而下的方式的最下层。<br>递归问题的求解过程：对于一个问题，如果存在递归解决方案，我们可以按照以下步骤来实施它。举个例子，我们将问题定义为有待实现的函数 F(X)，其中 X是函数的输入，同时也定义了问题的范围。然后，在函数 F(X) 中，我们将会：</p>
<ol>
<li>将问题逐步分解成较小的范围，例如 x0∈X, x1∈X, …, xn∈X；</li>
<li>调用函数 F(x0), F(x1), …, F(xn) 递归地 解决 X 的这些子问题；</li>
<li>最后，处理调用递归函数得到的结果来解决对应 X 的问题。</li>
</ol>
<p>递归问题的重复计算问题，使用缓存来暂存中间结果，然后让下一次递归计算直接利用缓存的结果来计算。该技术叫做记忆化。也可以直接使用参数化的形式。</p>
<p>下面将以leetcode的实例进行分析：<br>题目一：字符串的反转打印</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">printReverse</span><span class="params">(<span class="keyword">char</span> [] str)</span> </span>&#123;</span><br><span class="line">        helper(str,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    引入索引之后的帮助函数，通过记录当前索引，然后递归打印。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="comment">//基本案例，递归出口</span></span><br><span class="line">    <span class="keyword">if</span>(str==<span class="keyword">null</span>||index&gt;=str.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归求解子问题</span></span><br><span class="line">    helper(str,index+<span class="number">1</span>);</span><br><span class="line">    System.out.println(str[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目二：字符串反转</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">    reverseHelper(s,<span class="number">0</span>,s.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 同样的道理，在反转字符串的时候，我们也需要直接操作当前上下界的字符。</span></span><br><span class="line"><span class="comment">    * 所以需要利用索引来记录当前字符。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> s 待反转字符串</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> left 下界</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> right 上界</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverseHelper</span><span class="params">(<span class="keyword">char</span>[] s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)<span class="keyword">return</span>;<span class="comment">//递归出口</span></span><br><span class="line">    <span class="comment">//子问题的基本操作</span></span><br><span class="line">    <span class="keyword">char</span> temp=s[right];</span><br><span class="line">    s[right]=s[left];</span><br><span class="line">    s[left]=temp;</span><br><span class="line">    <span class="comment">//递归求解过程</span></span><br><span class="line">    reverseHelper(s,left+<span class="number">1</span>,right-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目三：链表节点两两交换，比如：<code>1-&gt;2-&gt;3-&gt;4</code>转换为<code>2-&gt;1-&gt;4-&gt;3</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;<span class="comment">//基本子问题</span></span><br><span class="line">    ListNode third=swapPairs(head.next.next);<span class="comment">//递归求解子问题。得到子问题的解</span></span><br><span class="line">    <span class="comment">//基本子问题的求解过程</span></span><br><span class="line">    ListNode second=head.next;</span><br><span class="line">    head.next=third;</span><br><span class="line">    second.next=head;</span><br><span class="line">    <span class="keyword">return</span>  second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目四：反转链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;<span class="comment">//递归出口</span></span><br><span class="line">        ListNode second=reverseList(head.next);<span class="comment">//递归求解子问题</span></span><br><span class="line">        <span class="comment">// 基本问题求解</span></span><br><span class="line">        head.next.next=head;<span class="comment">//头节点的下一个节点的下一个节点指向本身，实现依次交换。</span></span><br><span class="line">        head.next=<span class="keyword">null</span>;<span class="comment">//为了放置产生循环，需要进行尾部节点的截断工作。</span></span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>题目五：斐波拉契数列，为了实现斐波拉契数列中子问题重复求解的问题避免，采用记忆化的办法解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//记忆化缓存</span></span><br><span class="line">    <span class="keyword">return</span> fibHelper(map,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">int</span> <span class="title">fibHelper</span><span class="params">(Map&lt;Integer,Integer&gt; map, <span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(N))<span class="keyword">return</span> map.get(N);<span class="comment">//缓存技术</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;<span class="number">2</span>) res=N;</span><br><span class="line">    <span class="keyword">else</span> res=fibHelper(map,N-<span class="number">1</span>)+fibHelper(map,N-<span class="number">2</span>);<span class="comment">//根据递归树显然存在重复子问题问题。</span></span><br><span class="line">    map.put(N,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目六：二叉树的最大深度<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a><br>题解思路：在二叉树中，关于左右子树分别递归的例子属于经典操作，如何组合左右递归的结果才是不同的问题的差别所在，这就意味着这可以作为问题分析的出发点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//基本问题</span></span><br><span class="line">    <span class="keyword">int</span> left=maxDepth(root.left);<span class="comment">//子问题1</span></span><br><span class="line">    <span class="keyword">int</span> right=maxDepth(root.right);<span class="comment">//子问题2</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;<span class="comment">//子问题递推关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目六-拓展：二叉树的最小深度（叶节点到根节点的最小深度）<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a><br>题解思路：按照最大深度（题目六）的解题思路，不难得出下面的解题方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//基本问题</span></span><br><span class="line">    <span class="keyword">int</span> left=minDepth(root.left);<span class="comment">//子问题1</span></span><br><span class="line">    <span class="keyword">int</span> right=minDepth(root.right);<span class="comment">//子问题2</span></span><br><span class="line">    <span class="keyword">return</span> Math.min(left,right)+<span class="number">1</span>;<span class="comment">//子问题递推关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是上述的解决方案是错的，判断很简单，加入存在这样一棵树<code>[1,null,2,null,3]</code>，显然它的最小深度是3，按照上述的解决方案得到的答案是1.显然对于基本问题的划分除了问题。假设二叉树<code>[1,null,2,null,3]</code>显然在递归的时候，我们应该对其右子树进行递归得到答案。而不是到此结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br></pre></td></tr></table></figure>

<p>按照上面提供的思路：根节点的左子树为空，算出当前的最小深度为1.于是即便在递归右子树的时候，这个答案并不会更新，于是最终的答案便是1.错误在于：这个时候左子树为空，答案应该在右子树中产生。于是我们将基本问题划分为下面的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更改后的解决方案不会再出现第一种方案的问题。通过上述两个题目，可以深刻体会到递归子问题的划分问题的重要性。子问题有时候相对较隐蔽，只有包含了所有的递归路径，才能得到正确的答案。无独有偶，与上述题目异曲同工的题目，参考题目七，关键在于深刻体会其子问题的划分。</p>
<p>题目六-扩展：路径总和<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">https://leetcode-cn.com/problems/path-sum/</a><br>题解思路：</p>
<ol>
<li>广度优先搜索</li>
<li>深度优先搜索</li>
<li>递归（关键在于子问题的组合以及参数的变化）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> targetSum==root.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  hasPathSum(root.left,targetSum-root.val)||hasPathSum(root.right,targetSum-root.val);<span class="comment">//子问题的组合方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在二叉树中通常会出现这种情况，在遍历过程中，直接通过参数的变化来记录行动轨迹，这样的好处是直接根据参数的值来判断终止条件。当然有时候参数变化不便于代码的实现，我们可以通过引入全局变量的方式来记录行动轨迹以及判断终止条件。参考下面的题目：</p>
<p>题目六-扩展：二叉搜索树中第k小的节点<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/</a><br>题解思路：中序遍历，并且通过递归的方式实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ans=-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//终止条件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    help(root,k);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    help(root.left,k);</span><br><span class="line">    <span class="comment">// 中序遍历是有序序列</span></span><br><span class="line">    <span class="comment">// count 记录已遍历的长度</span></span><br><span class="line">    <span class="comment">// k==count 时 就是要找的值</span></span><br><span class="line">    <span class="comment">// 但是我们要提前返回，右边分支就不用遍历了</span></span><br><span class="line">    <span class="comment">// 右边不遍历，所以count值不会再变化了，所以 ans 可能会被覆盖，需要加判断，只修改一次</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span>(k==count)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            ans=root.val;</span><br><span class="line">            flag=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;count)</span><br><span class="line">        help(root.right,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过引入全局变量有时候会使得递归的描写变得简单，除了上述的题目，下面的题目也是通过引入全局变量的方式使得递归的实现变得容易。</p>
<p>题目六-扩展：路径总和II<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum-ii/">https://leetcode-cn.com/problems/path-sum-ii/</a><br>题解思路：深度优先搜索</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">Deque&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    dfs(root, sum);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这里提供了一种思路：通过定义全局变量，利用void类型的方法直接对该全局变量进行操作处理。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> sum</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    path.offerLast(root.val);</span><br><span class="line">    sum -= root.val;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == <span class="number">0</span>) &#123;</span><br><span class="line">        ret.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;(path));</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root.left, sum);</span><br><span class="line">    dfs(root.right, sum);</span><br><span class="line">    path.pollLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述二叉树的深度优先搜索的解决办法甚至可以作为模板来解决问题。下面的题目直接使用上述的模板来解决。</p>
<p>题目六-扩展：根节点到叶节点的总和。<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/</a><br>题解思路：深度优先搜索</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> LinkedList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">Deque&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    dfsHelper(root);</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; integers : ret) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer integer : integers) &#123;</span><br><span class="line">            sum = (sum * <span class="number">10</span> + integer);</span><br><span class="line">        &#125;</span><br><span class="line">        res += sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfsHelper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> ;</span><br><span class="line">    path.offerLast(root.val);</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">        ret.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;(path));</span><br><span class="line">    &#125;</span><br><span class="line">    dfsHelper(root.left);</span><br><span class="line">    dfsHelper(root.right);</span><br><span class="line">    path.pollLast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目七：有序链表的合并。<code>list1:1-&gt;3</code>,<code>list2:2-&gt;4</code>. <code>result:1-&gt;2-&gt;3-&gt;4</code>.<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a><br>题解思路：基本的问题的分类讨论有时候也是必要的。不光如此，基本的组合方式也是必要考虑的问题，比如上述中的二叉树的高度求解问题，其中涉及左右子树的问题，如何将左右子树的基本问题组合成最终问题的解是一个重要的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//情况一</span></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//情况二</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//情况三</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//情况四</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目八：平衡二叉树的判断<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">https://leetcode-cn.com/problems/balanced-binary-tree/</a><br>题解思路：该题完全借鉴二叉树深度求解的思路，直接对左右子树进行分别的递归求解，这就说明二叉树的左右子树的划分天然的成为子问题分解的界限。关于二叉树的相关问题，这也是一个比较重要的思想。同样的道理，在考虑基本问题的组合方式的时候，我们也需要考虑子问题的组合方式，以及子问题与基本问题之间的组合方式。下面这道题就分别考虑了子问题的组合方式，基本问题与子问题的组合方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//递归出口</span></span><br><span class="line">    <span class="keyword">boolean</span> flag= Math.abs(maxDepth(root.left)-maxDepth(root.right))&lt;=<span class="number">1</span>;<span class="comment">//基本子问题</span></span><br><span class="line">    <span class="keyword">return</span> flag&amp;&amp;isBalanced(root.left)&amp;&amp;isBalanced(root.right);<span class="comment">//递归求解其他子问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目九：二叉树的右视角(从右边看到二叉树的元素构成的列表)<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">https://leetcode-cn.com/problems/binary-tree-right-side-view/</a><br>题解思路：简单来说结果为根节点加上右子树的结果，然后加上左子树的结果去掉右子树高度那一部分的结果<br>总结归纳：从上述几道二叉树的相关题目来看，“二叉树的左右子树作为天然的递归子问题划分的界限”这个结论无疑是合理的。该问题的关键还是在于递归子问题之间的组合方式。仔细体会上述几道关于二叉树的问题，不难发现，都是基于左右子树的天然划分，然后将子问题按照不同的方式进行组合最终得到我们想要的答案。如此一来，关于二叉树的问题，则有了基本的做题法则。基于二叉树的递归定义，在解决二叉树问题的同时基于其递归定义借助于递归来组合出不同的答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; rs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> rs;<span class="comment">//递归出口</span></span><br><span class="line">    rs.add(root.val);</span><br><span class="line">    List&lt;Integer&gt; right = rightSideView(root.right);</span><br><span class="line">    List&lt;Integer&gt; left = rightSideView(root.left);</span><br><span class="line">    rs.addAll(right);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = right.size();i&lt;left.size();i++) rs.add(left.get(i));</span><br><span class="line">    <span class="keyword">return</span> rs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目十：把二叉搜索树转换为累加树<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/</a><br>题解思路：右根左遍历<br>总结归纳：再提一句<strong>二叉树的左右子树是递归子问题的天然划分</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        convertBST(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">        convertBST(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目十一：二叉搜索树的序列化<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binode-lcci/">https://leetcode-cn.com/problems/binode-lcci/</a><br>题解思路：中序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode head = <span class="keyword">new</span> TreeNode(-<span class="number">1</span>);   <span class="comment">// 为了返回单向链表的头节点而多设的一个节点</span></span><br><span class="line">    TreeNode perv = <span class="keyword">null</span>;               <span class="comment">// 指向当前节点的前一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBiNode</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> head.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="keyword">return</span>;&#125;</span><br><span class="line">        helper(root.left);</span><br><span class="line">        <span class="keyword">if</span> (perv == <span class="keyword">null</span>) &#123;     <span class="comment">// 第一个节点</span></span><br><span class="line">            perv = root;        <span class="comment">// 记录第一个节点</span></span><br><span class="line">            head.right = root;  <span class="comment">// 记录它，它将作为单链表的表头</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                <span class="comment">// 第一个节点之后的节点</span></span><br><span class="line">            perv.right = root;  <span class="comment">// 前一个节点的右指针指向当前节点</span></span><br><span class="line">            perv = root;        <span class="comment">// 更新perv指向</span></span><br><span class="line">        &#125;</span><br><span class="line">        root.left = <span class="keyword">null</span>;       <span class="comment">// 当前节点的左指针设为null</span></span><br><span class="line">        helper(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><p>分治算法：分支算法要求问题本质是递归的，算法多次调用自身去解决子问题，然后将子问题的解进行合并得到问题的解。<br>分治法的思想本质：将原问题分解为几个规模较小的子问题，递归地求解这些子问题，合并子问题的解得到原问题的解。<br>分治算法的几个步骤：</p>
<ol>
<li>分解：原问题分解为几个规模较小的子问题。</li>
<li>递归：递归求解子问题</li>
<li>合并：将子问题的解合并得到原问题的解。</li>
</ol>
<p>分治算法需要注意的是：在问题进行分解的时候可能产生不同于原问题的子问题，这部分子问题需要单独处理。</p>
<p>题目一：最大子序列<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a><br>题解参考：子序列作为序列的子集，只能存在在序列的上半部分，下半部分，或横跨中的部分，基于此，我们将问题分为几个子问题去求解。对于上半部分以及下半部分的划分，显然是独立的子问题，求解的方式也是直接借助于递归求解即可。但是关于横跨中间部分的子问题，他显然不适合于用类似于上半部分（下半部分）的方法求解。关于此问题，需要单独求解。最后将上述三个问题组合即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>  subArraySum(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">crossingSum</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 一定会包含 nums[mid] 这个元素</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftSum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="comment">// 左半边包含 nums[mid] 元素，最多可以到什么地方</span></span><br><span class="line">    <span class="comment">// 走到最边界，看看最值是什么</span></span><br><span class="line">    <span class="comment">// 计算以 mid 结尾的最大的子数组的和</span></span><br><span class="line">    <span class="comment">//这里不仅可以维护最大和，还可以维护最大和产生的索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &gt;= left; i--) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; leftSum) &#123;</span><br><span class="line">            leftSum = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rightSum = Integer.MIN_VALUE;</span><br><span class="line">    <span class="comment">// 右半边不包含 nums[mid] 元素，最多可以到什么地方</span></span><br><span class="line">    <span class="comment">// 计算以 mid+1 开始的最大的子数组的和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; rightSum) &#123;</span><br><span class="line">            rightSum = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftSum + rightSum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subArraySum</span><span class="params">(<span class="keyword">int</span>[] num,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left==right)<span class="keyword">return</span> num[left];<span class="comment">//子问题递归出口。</span></span><br><span class="line">    <span class="keyword">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;<span class="comment">//子问题分解标志。</span></span><br><span class="line">    <span class="keyword">return</span> maxSum(subArraySum(num,left,mid),</span><br><span class="line">            subArraySum(num,mid+<span class="number">1</span>,right),crossingSum(num,left,mid,right));<span class="comment">//递归体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="keyword">int</span> sum1,<span class="keyword">int</span> sum2,<span class="keyword">int</span> sum3)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.max(sum1,Math.max(sum2,sum3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目二：查找主要元素(该元素的数量超过1/2)<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">https://leetcode-cn.com/problems/majority-element/</a><br>题解思路：二分法求解,二分之后的一部分一定存在主要元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElementDivide</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> majorityElementRec(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">majorityElementRec</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case; the only element in an array of size 1 is the majority</span></span><br><span class="line">    <span class="comment">// element.</span></span><br><span class="line">    <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[lo];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// recurse on left and right halves of this slice.</span></span><br><span class="line">    <span class="keyword">int</span> mid = (hi - lo) / <span class="number">2</span> + lo;</span><br><span class="line">    <span class="keyword">int</span> left = majorityElementRec(nums, lo, mid);</span><br><span class="line">    <span class="keyword">int</span> right = majorityElementRec(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">    <span class="comment">// if the two halves agree on the majority element, return it.</span></span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// otherwise, count each element and return the &quot;winner&quot;.</span></span><br><span class="line">    <span class="keyword">int</span> leftCount = countInRange(nums, left, lo, hi);</span><br><span class="line">    <span class="keyword">int</span> rightCount = countInRange(nums, right, lo, hi);</span><br><span class="line">    <span class="keyword">return</span> leftCount &gt; rightCount ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="动态规划介绍"><a href="#动态规划介绍" class="headerlink" title="动态规划介绍"></a>动态规划介绍</h2><p>动态规划（<code>dynamic programming</code>）与分治方法相似，都是通过组合子问题的解来求解原问题（在这里，”<code>programming</code>“指的是一种表格法，并非编写计算机程序）。分治方法将问题划分为互不相交的子问题，递归地求解子问题，再将它们的解组合起来，求出原问题的解。与之相反，动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子问题）。在这种情况下，分治算法会做许多不必要的工作，它会反复地求解那些公共子子问题。而动态规划算法对每个子子问题只求解一次，将其解保存在一个<strong>表格</strong>中，从而无需每次求解一个子问题时都重新计算，避免了这种不必要的计算工作。<br>动态规划方法通常用来求解最优化问题（<code>optimization problem</code>）。这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值（最小值或最大值）的解。我们称这样的解为问题的一个最优解（<code>an optimal solution</code>），而不是最优解（<code>the optimal solution</code>），因为可能有多个解都达到最优值。<br>我们通常按如下 4 个步骤来设计一个动态规划算法∶ </p>
<ol>
<li>刻画一个最优解的结构特征。 </li>
<li>递归地定义最优解的值。</li>
<li>计算最优解的值，通常采用自底向上的方法。 </li>
<li>利用计算出的信息构造一个最优解。</li>
</ol>
<p>步骤 1～3 是动态规划算法求解问题的基础。如果我们仅仅需要一个最优解的值，而非解本身，可以忽略步骤 4。如果确实要做步骤 4，有时就需要在执行步骤 3 的过程中维护一些额外信息，以便用来构造一个最优解。</p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>钢条切割问题：给定一段长度为 n 英寸的钢条和一个价格表 Pi;（i=1，2，…，n），求切割钢条方案，使得销售收益 Ri，最大。注意，如果长度为 n英寸的钢条的价格 p，足够大，最优解可能就是完全不需要切割。</p>
<img src="/2021/04/20/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E9%92%A2%E6%9D%A1%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98.PNG" class>

<p>按照动态规划算法分析的步骤，我们首先刻画一个最优解的结构特征。</p>
<img src="/2021/04/20/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E9%92%A2%E6%9D%A1%E6%9C%80%E4%BC%98%E8%A7%A3%E5%88%BB%E7%94%BB.PNG" class>

<p>其中Pn代表不进行切割，显然上述的公式刻画了最优解与子问题之间的关系。根据如上的结构特征便可以构造递归的递推关系。</p>
<p>此外，如果切割的时候只考虑对切割后的两截钢条中的一截进行切割，可以得到如下更加简单的最优解的结构特征。</p>
<img src="/2021/04/20/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/%E9%92%A2%E6%9D%A1%E6%9C%80%E4%BC%98%E8%A7%A3%E5%88%BB%E7%94%BB%E4%BA%8C.PNG" class>

<p>基于上述的递推关系，我们可以得到下面的递归程序.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cut(<span class="keyword">int</span> n,<span class="keyword">int</span>[p])&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> q=Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        q=max(q,p[i]+cut(n-i,p));</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述的递归程序，明显存在重复子问题的求解，通过刻画其递归调用树，我们可以清晰地看出子问题的重复求解问题：</p>
<p>为了避免重复子问题的求解，我们通过记忆化的方式来实现子问题预先的存储，然后通过查表得方式直接获取已经求解出的子问题。<br>动态规划的实现方法：带备忘录的自顶向下法，自底向上法。</p>
<p><strong>带备忘录的自顶向下法</strong>：通过添加记忆数组和哈希表的方式来存储已经求解过的子问题，每次递归时，首先查看该子问题是否已经存在在哈希表中，如果没有则递归求解，并且将该子问题的解记录在备忘录中，如果存在该解，直接从备忘录中返回即可。</p>
<p><strong>自底向上法</strong>：需要恰当定义子问题规模的概念，使得每个子问题的求解仅仅只依赖于规模更加小的子问题，然后我们每次求解子问题时，直接依赖于已经求解的更小的子问题即可。这样一来，每个子问题子需要求解一次。</p>
<p>这里插播一个概念：<strong>最优子结构</strong><br>问题的最优解由相关子问题的最优解合成，并且子问题可以独立进行求解。</p>
<h2 id="动态规划应用场景："><a href="#动态规划应用场景：" class="headerlink" title="动态规划应用场景："></a>动态规划应用场景：</h2><p>适合使用动态规划来求解的问题需要具备两个条件：</p>
<ul>
<li>最优子结构</li>
<li>子问题重叠</li>
</ul>
<h3 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h3><p>用动态规划方法求解最优化问题的第一步就是刻画最优解的结构。如果—个问题的最优解包含其子问题的最优解，我们就称此问题具有最优子结构性质。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个好线索（当然，具有最优子结构性质也可能意味着适合应用贪心策略）。使用动态规划方法时，我们用子问题的最优解来构造原问题的最优解。因此，我们必须小心确保考察了最优解中用到的所有子问题。<br>发掘最优子结构性质的通用模式：</p>
<ol>
<li>证明问题最优解的第一个组成部分是做出一个选择，例如，选择钢条第一次切割位置。做出这次选择会产生一个或多个待解的子问题。</li>
<li>对于一个给定问题，在其可能的第一步选择中，你假定已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择。</li>
<li>给定可获得最优解的选择后，你确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间。</li>
<li>利用”剪切一粘贴”（cut-and-paste）技术证明∶作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。证明这一点是利用反证法;假定子问题的解不是其自身的最优解，那么我们就可以从原问题的解中”剪切”掉这些非最优解，将最优解”粘贴”进去，从而得到原问题一个更优的解，这与最初的解是原问题最优解的前提假设矛盾。如果原问题的最优解包含多个子问题，通常它们都很相似，我们可以将针对一个子问题的”剪切一粘贴”论证方法稍加修改，用于其他子问题。</li>
</ol>
<p>对于不同问题领域，最优子结构的不同体现在两个方面; </p>
<ol>
<li>原问题的最优解中涉及多少个子问题，以及</li>
<li>在确定最优解使用哪些子问题时，我们需要考察多少种选择。</li>
</ol>
<p>以切割钢条为例：<br>在钢条切割问题中，长度为n的钢条的最优切割方案仅仅使用一个子问题（长度为 n一i的钢条的最优切割），但我们必须考察i的n种不同取值，来确定哪一个会产生最优解。</p>
<h3 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h3><p>适合用动态规划方法求解的最优化问题应该具备的第二个性质是子问题空间必须足够”小”，即问题的递归算法会反复地求解相同的子问题，而不是一直生成新的子问题。一般来讲，不同子问题的总数是输入规模的多项式函数为好。如果递归算法反复求解相同的子问题，我们就称最优化问题具有重叠子问题（<code>overlapping subproblems</code>）性质的。与之相对的，适合用分治方法求解的问题通常在递归的每—步都生成全新的子问题。动态规划算法通常这样利用重叠子问题性质，对每个子问题求解一次，将解存入一个表中，当再次需要这个子问题时直接查表，每次查表的代价为常量时间。</p>
<h2 id="动态规划分类"><a href="#动态规划分类" class="headerlink" title="动态规划分类"></a>动态规划分类</h2><p>用动态规划解决问题的过程有以下几个关键点：状态定义，状态的转移，初始化和边界条件。</p>
<p><strong>状态定义</strong> 就是定义子问题，如何表示目标规模的问题和更小规模的问题。例如常见的方法：定义状态 <code>dp[n]</code>，表示规模为 n的问题的解，<code>dp[n - 1]</code> 就表示规模为 <code>n−1</code> 的子问题的解。在实战中 <code>dp[n]</code> 的具体含义需要首先整理清楚再往下做。</p>
<p><strong>状态转移</strong> 就是子问题之间的关系，例如定义好状态 <code>dp[n]</code>，此时子问题是 <code>dp[n-1]</code> 等，并且大规模的问题的解依赖小规模问题的解，此时需要知道怎样通过小规模问题的解推出大规模问题的解。这一步就是列状态转移方程的过程。一般的状态转移方程可以写成如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[n] &#x3D; f(dp[i]) 其中 i &lt; n</span><br></pre></td></tr></table></figure>

<h3 id="线性动态规划"><a href="#线性动态规划" class="headerlink" title="线性动态规划"></a>线性动态规划</h3><p>线性动态规划主要特点就是：状态的推导是按照问题规模 i 从小到大依次推过去的，较大规模的问题的解依赖较小规模的问题的解。这里问题规模为 i 的含义是考虑前 i 个元素 <code>[0..i]</code> 时问题的解。</p>
<p>状态定义：</p>
<p><code>dp[n] := [0..n]</code> 上问题的解</p>
<p>状态转移:</p>
<p><code>dp[n] = f(dp[n-1], ..., dp[0])</code></p>
<p>从以上状态定义和状态转移可以看出，大规模问题的状态只与较小规模的问题有关，而问题规模完全用一个变量 i 表示，i 的大小表示了问题规模的大小，因此从小到大推 i 直至推到 n，就得到了大规模问题的解，这就是线性动态规划的过程。</p>
<h4 id="单串"><a href="#单串" class="headerlink" title="单串"></a>单串</h4><p>单串 <code>dp[i]</code> 线性动态规划最简单的一类问题，输入是一个串，状态一般定义为 <code>dp[i] := 考虑[0..i]</code>上，原问题的解。</p>
<p>题目一：最长递增子序列<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a><br>解题思路：<br>定义 <code>dp[i]</code> 为考虑前 i个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 <code>nums[i]</code>必须被选取。</p>
<p>我们从小到大计算 <code>dp[]</code>数组的值，在计算 <code>dp[i]</code>之前，我们已经计算出 <code>dp[0…i−1]</code>的值，则状态转移方程为：<br><code>dp[i]=max(dp[j])+1,其中 0≤j&lt;i 且 num[j]&lt;num[i]</code></p>
<p>即考虑往 <code>dp[0…i−1]</code>中最长的上升子序列后面再加一个 <code>nums[i]</code>。由于 <code>dp[j]</code> 代表 nums[0…j]中以<code>nums[j]</code>结尾的最长上升子序列，所以如果能从<code>dp[j]</code>这个状态转移过来，那么<code>nums[i]</code>必然要大于<code>nums[j]</code>，才能将<code>nums[i]</code>放在<code>nums[j]</code>后面以形成更长的上升子序列。</p>
<p>最后，整个数组的最长上升子序列即所有<code>dp[i]</code>中的最大值。</p>
<p><code>LISlength=max(dp[i]),其中 0≤i&lt;n</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//最小子问题</span></span><br><span class="line">    <span class="keyword">int</span> maxans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxans = Math.max(maxans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目二：最长递增子序列的个数<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/</a><br>题解思路：</p>
<ol>
<li>假设以<code>nums[i]</code>结尾的数组的最长递增子序列为<code>length[i]</code>,并且具有该长度的递增子序列的数量为<code>count[i]</code>.</li>
<li>对于每个<code>i&lt;j</code>和一个<code>nums[i]&lt;nums[j]</code>,我们可以将nums[j]附着在以nums[i]结尾的最长子序列上。</li>
<li>如果这些序列比 <code>length[j]</code> 长，那么我们就知道我们有<code>count[i]</code>个长度为 <code>length</code>的序列。如果这些序列的长度与 <code>length[j]</code> 相等，那么我们就知道现在有<code>count[i]</code>个额外的序列（即<code>count[j]+=count[i]</code>）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) <span class="keyword">return</span> N;</span><br><span class="line">    <span class="keyword">int</span>[] lengths = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//lengths[i] = length of longest ending in nums[i]</span></span><br><span class="line">    <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//count[i] = number of longest ending in nums[i]</span></span><br><span class="line">    Arrays.fill(counts, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; ++i) <span class="keyword">if</span> (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lengths[i] &gt;= lengths[j]) &#123;</span><br><span class="line">                lengths[j] = lengths[i] + <span class="number">1</span>;</span><br><span class="line">                counts[j] = counts[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lengths[i] + <span class="number">1</span> == lengths[j]) &#123;</span><br><span class="line">                counts[j] += counts[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> longest = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> length: lengths) &#123;</span><br><span class="line">        longest = Math.max(longest, length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lengths[i] == longest) &#123;</span><br><span class="line">            ans += counts[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目三：最大子序列和<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/">https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/</a><br>题解思路：用<code>f(i)</code>表示第i个数结尾的最大子序列和，那么问题的答案便是<code>max(f(i))</code>，其中<code>0&lt;=i&lt;=n</code>.如何确定每个f(i),需要根据f(i-1)的结果与当前的<code>nums[i]</code>作比较，得到如下的结果:<br><code>f(i)=max(nums[i],f(i-1)+nums[i])</code>.</p>
<p>很明显，这样得出的结果是符合题目的要求的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] f=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> maxRes=nums[<span class="number">0</span>];</span><br><span class="line">    f[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        f[i]=Math.max(nums[i],nums[i]+f(i-<span class="number">1</span>));</span><br><span class="line">        maxRes=Math.max(maxRes,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目四：乘积最大的子数组<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-subarray/">https://leetcode-cn.com/problems/maximum-product-subarray/</a><br>题解思路：常规思路出发，借助于上题，我们不难得出这样的结论。<code>f(i)=max(f(i)*a[i],a[i])</code>。但是显然在这里是错误的，以数组<code>[3,2,-3,2,-4]</code>为例，乘积最大的子数组应该是该数组本身，按照上述的解决方案得到应该是<code>[3,2]</code>.显然，当前位置的最优解并不一定是由前一个位置的最优解转移而来。由于存在符号的影响，我们需要维护两个记忆化数组，如果当前数为正，那么我们需要得到之前的最大数，如果当前数位负，我们希望之前存在一个最小的负数，这样得到的结果才是当前最大的结果。于是需要维护两个表。</p>
<p><code>f(i)max=max(f(i-1)max*a[i],f(i-1)min*a[i],a[i])</code>;</p>
<p><code>f(i)min=min(f(i-1)max*a[i],f(i-1)min*a[i],a[i])</code>;</p>
<p>有了上述的两个动态规划状态方程，不难得到如下的解决方案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] maxF = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="keyword">int</span>[] minF = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    System.arraycopy(nums, <span class="number">0</span>, maxF, <span class="number">0</span>, length);</span><br><span class="line">    System.arraycopy(nums, <span class="number">0</span>, minF, <span class="number">0</span>, length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        maxF[i] = Math.max(maxF[i - <span class="number">1</span>] * nums[i], Math.max(nums[i], minF[i - <span class="number">1</span>] * nums[i]));</span><br><span class="line">        minF[i] = Math.min(minF[i - <span class="number">1</span>] * nums[i], Math.min(nums[i], maxF[i - <span class="number">1</span>] * nums[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = maxF[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        ans = Math.max(ans, maxF[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目五：打家劫舍<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">https://leetcode-cn.com/problems/house-robber/</a><br>题解思路：<code>f(i)=max(f(i-1),f(i-2)+a[i])</code>,其中<code>f[0]=a[0],f[1]=max(a[0],a[1])</code>;在此基础上，打家劫舍如果考虑房屋数组的是循环的，那么问题则变成当考虑第一间屋子的时候，舍弃最后一间屋子，当考虑最后一间屋子的时候，舍弃第一间屋子，通过比较两边循环寻找出的最大值，选择其中大的作为最终的答案即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.length;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)<span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span>[] f=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    f[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    f[<span class="number">1</span>]=Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        f[i]=Math.max(f[i-<span class="number">1</span>],f[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>题目六：斐波拉契子序列最长长度<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/">https://leetcode-cn.com/problems/length-of-longest-fibonacci-subsequence/</a><br>题解思路：将斐波那契式的子序列中的两个连续项 <code>A[i]</code>, <code>A[j]</code> 视为单个结点 <code>(i, j)</code>，整个子序列是这些连续结点之间的路径。只有当 <code>A[i] + A[j] == A[k]</code> 时，两结点 <code>(i, j)</code> 和 <code>(j, k)</code> 才是连通的。设 <code>longest[i, j]</code> 是结束在 <code>[i, j]</code> 的最长路径。那么 如果 <code>(i, j)</code> 和 <code>(j, k)</code> 是连通的， <code>longest[j, k] = longest[i, j] + 1</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = A.length;</span><br><span class="line">    Map&lt;Integer, Integer&gt; index = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        index.put(A[i], i);</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, Integer&gt; longest = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = index.getOrDefault(A[k] - A[j], -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; j) &#123;</span><br><span class="line">                <span class="comment">// Encoding tuple (i, j) as integer (i * N + j)</span></span><br><span class="line">                <span class="keyword">int</span> cand = longest.getOrDefault(i * N + j, <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">                longest.put(j * N + k, cand);</span><br><span class="line">                ans = Math.max(ans, cand);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans &gt;= <span class="number">3</span> ? ans : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目七：最长等差数列<br>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/">https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/</a><br>题解思路：与上述的最长斐波拉契数列的最长子序列的思路一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubsequence</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> difference)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = arr.length;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap();<span class="comment">//用map存储已经求过的最长子序列值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>;<span class="comment">//将自己计算在内</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(arr[i] - difference)) &#123;<span class="comment">//判断是否存在差值为difference的最长子序列</span></span><br><span class="line">            dp[i] = Math.max(dp[i], map.get(arr[i] - difference) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(arr[i],dp[i]);<span class="comment">//存于map，以便后续查找</span></span><br><span class="line">        res = Math.max(res,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划与分治法等算法之间差异"><a href="#动态规划与分治法等算法之间差异" class="headerlink" title="动态规划与分治法等算法之间差异"></a>动态规划与分治法等算法之间差异</h1><p>我们知道递归，分治法，动态规划之间存在相同的因素，也存在各自的特点。对上述三者，递归是基础，作为他们三者的思想基础。三者都有子问题的划分，子问题的划分就来自于递归的本质，子问题的组合是自底向上的过程，而递归的过程是自顶向下的过程。两者出发的角度不同，却殊途同归。分治法的概念来源就在于子问题的划分，多个子问题的组合才能得到最终问题的解。问题的关键在于子问题划分与子问题的组合；并且还有一点，分治法的子问题是相互独立的。独立性是说明子问题之间的依赖关系。动态规划从另一个角度出发，探讨的是子问题之间的关联性。两个子问题之间存在某种关联性，动态规划通过关联性的记忆来解决分治法中子问题的递归求解的重复问题。<br>从另一个层面，我们清楚递归，分治法都是自定向下的算法，子问题的划分本身就基于子问题的独立性，也就是说其实子问题的组合方式已经是确定的，我们只需要明确子问题所有的组合方式即可。这一点动态规划自顶向下的方法天然继承两者的特点，只是借助记忆化技术减少子问题的重复求解问题。但是基于自底向上的动态规划方法，在借助于子问题之间的依赖关系的时候，子问题一步步扩大的过程中组合的方式可能是不确定的。在不确定之间，我们需要抉择，选择一种可操作性为是的作为我们的组合方式。于是我们的工作中心之一便是：子问题的扩大的方式选择与实现。</p>
<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>贪心算法通过每一步做出当前的局部最优解来获得最终的解，该算法不能保证获得的是一个全局最优解，但是在某些情况下也能获得全局最优解，这也决定了在某些应用场景下，贪心算法是我们首选的算法。通常的应用领域包括：哈夫曼编码，最小生成树，单源最短路径，集合覆盖问题等。<br><strong>贪心算法的步骤</strong>：</p>
<ol>
<li>确定问题的最优子结构.</li>
<li>设计一个递归算法。</li>
<li>证明如果做出一个贪心选择，则子问题只剩下一个。</li>
<li>证明贪心的选择总是安全的。</li>
<li>设计一个递递归算法实现贪心策略</li>
<li>将递归改成迭代实现。</li>
</ol>
<p><strong>贪心算法关键要素</strong>：<br>贪心选择性质：在动态规划中，我们通常需要寻找子问题之间的依赖关系，然后设计自底向上的算法去实现，而贪心算法中，我们根据当前做出当前的最优解即可。贪心算法进行选择时可能依赖之前做出的选择，但不依赖任何将来的选择或是子问题的解。如果贪心选择时，我们面临多种选择，通常意味着我们需要改进贪心选择机制，使得其更加高效。总结起来，贪心算法需要做的论证是：<strong>将子问题的最优解与当前我们的贪心选择组合在一起就能生成原问题的最优解</strong>。</p>
<p><strong>经典问题</strong>：</p>
<ul>
<li>0-1背包问题：</li>
</ul>
<p>我们有一堆物品S={a1,a2,…,an}S={a1,a2,…,an},每一个物品ai都有一个重量wi和一个价值vi.现在有一个背包，这个背包的容量为WW,现在要将这些物品在不超出背包容量的情况下选择性的放入背包，使得背包里面物品的价值最大，物品不能只选取其中一部分，必须选择整个，或者不选！</p>
<ul>
<li>分数背包问题：</li>
</ul>
<p>这个问题和上面的问题比较相似，唯一不同的就是该问题里面的物品可以进行分割，即可以只选取一个物品ai的一部分。</p>
<p>上述两个问题，其中0-1背包问题是不能用贪心算法来求解的，而分数背包问题是利用贪心算法求解的典范。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Algorithm/" rel="tag"># Algorithm</a>
              <a href="/tags/Dynamic-Programming/" rel="tag"># Dynamic Programming</a>
              <a href="/tags/Divide-Conquer/" rel="tag"># Divide Conquer</a>
              <a href="/tags/Greedy/" rel="tag"># Greedy</a>
              <a href="/tags/Recursion/" rel="tag"># Recursion</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/15/scala%E5%9F%BA%E7%A1%80/" rel="prev" title="scala基础">
      <i class="fa fa-chevron-left"></i> scala基础
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" rel="next" title="排序算法">
      排序算法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#What-I%E2%80%99m-doing-right-now%EF%BC%8CI%E2%80%99m-chasing-perfection"><span class="nav-number">1.</span> <span class="nav-text">What I’m doing right now，I’m chasing perfection</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">2.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">分治算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">4.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BB%8B%E7%BB%8D"><span class="nav-number">4.1.</span> <span class="nav-text">动态规划介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-number">4.2.</span> <span class="nav-text">案例分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="nav-number">4.3.</span> <span class="nav-text">动态规划应用场景：</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-number">4.3.1.</span> <span class="nav-text">最优子结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98"><span class="nav-number">4.3.2.</span> <span class="nav-text">重叠子问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%86%E7%B1%BB"><span class="nav-number">4.4.</span> <span class="nav-text">动态规划分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">4.4.1.</span> <span class="nav-text">线性动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%B8%B2"><span class="nav-number">4.4.1.1.</span> <span class="nav-text">单串</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%8E%E5%88%86%E6%B2%BB%E6%B3%95%E7%AD%89%E7%AE%97%E6%B3%95%E4%B9%8B%E9%97%B4%E5%B7%AE%E5%BC%82"><span class="nav-number">5.</span> <span class="nav-text">动态规划与分治法等算法之间差异</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">贪心算法</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="RockCohen"
      src="/images/hugo.png">
  <p class="site-author-name" itemprop="name">RockCohen</p>
  <div class="site-description" itemprop="description">a programmer</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/rockcohen" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;rockcohen" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xluo0616@gmail.com" title="E-Mail → mailto:xluo0616@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RockCohen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
