<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rockcohen.gitee.io","root":"/blog/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="JVM基础">
<meta property="og:url" content="https://rockcohen.gitee.io/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Rock Cohen">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E7%A7%91%E6%AF%94.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%A1%A8.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E7%AC%A6.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%9E%B6%E6%9E%84.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B.png">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%91%A8%E6%9C%9F.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E5%A4%8D%E5%88%B6%E6%83%85%E5%86%B5.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png">
<meta property="article:published_time" content="2021-04-11T08:41:32.000Z">
<meta property="article:modified_time" content="2021-04-17T14:29:08.256Z">
<meta property="article:author" content="RockCohen">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rockcohen.gitee.io/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E7%A7%91%E6%AF%94.PNG">

<link rel="canonical" href="https://rockcohen.gitee.io/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JVM基础 | Rock Cohen</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Rock Cohen</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Cohen</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rockcohen.gitee.io/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/hugo.png">
      <meta itemprop="name" content="RockCohen">
      <meta itemprop="description" content="a programmer">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock Cohen">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-11 16:41:32" itemprop="dateCreated datePublished" datetime="2021-04-11T16:41:32+08:00">2021-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-17 22:29:08" itemprop="dateModified" datetime="2021-04-17T22:29:08+08:00">2021-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <img src="/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E7%A7%91%E6%AF%94.PNG" class>

<span id="more"></span>

<h1 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h1><p>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上面的机器指令执行。其特点如下：</p>
<ul>
<li>一次编译，到处运行:基于Java的指令系统的实现是基于<strong>栈</strong>设计的，不依赖于具体系统的寄存器，从而实现可跨平台的，指令集小的优点，带来的缺点也很显然：同样的程序高级语言代码，需要更多的指令完成其目的，导致性能下降。</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
<p>Java虚拟机的本质属于程序虚拟机，其位置在操作系统之上。</p>
<h1 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h1><h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p>Java 中，在虚拟机自动内存管理机制的帮助下，不需要为每一个<code>new</code>的对象去写培对的<code>delete/free</code>代码。同时，内存管理交由虚拟机来管理之后，使得排查错误、修正问题将会成为艰巨的任务。</p>
<p>Java虚拟机在执行时会把所管理的内存划分为若干个不同的区域。每个区域有各自的用途，创建和销毁时间。</p>
<img src="/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.PNG" class>

<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，它可以看作是当前线程执行的字节码的行号指示器。主要时程序控制流的指示器，完成分支，循环，跳转，异常处理，线程恢复等工作。Java虚拟机的多线程是通过线程轮流切换、分配处理执行时间的方式来完成，任何时候，一个处理器都只会执行一条线程中的指令。每个线程拥有独立的程序计数器，线程之间相互独立，互不影响。这类内存区域叫做<strong>线程私有</strong>的内存。如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指零的地址，如果执行的是<strong>本地(<code>native</code>方法</strong>,这个计数器值应该为空(<code>undefined</code>)。该区域是唯一一个在《Java虚拟机规范》中没有规定任何<code>OutOfMemory</code>的区域。</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>Java虚拟机栈也是线程私有的，其生命周期与线程相同。描述Java方法执行的线程内存模型：用于存储局部变量表，操作数栈，动态连接，方法出口等信息。每一个方法被调用直到执行完毕分过程中，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。</p>
<p><strong>局部变量表</strong>：</p>
<p>存放编译期间可知的各种Java虚拟机基本数据类型（<code>boolean</code>,<code>byte</code>,<code>char</code>,<code>short</code>,<code>int</code>,<code>float</code>,<code>long</code>,<code>double</code>,)、对象引用(<code>reference</code> 类型，并不等同于对象本身，可能是指向一个对象的其实地址指针，指向一个代表对象的句柄或者对象的相关位置)和<code>returnAddress</code>类型(指向了一条字节码指令的地址)</p>
<p>这些数据类型的局部变量表中的存储空间以局部变量槽(<code>Slot</code>)来表示，其中<code>long</code>与<code>double</code>类型会占用两个槽，其余变量占用一个槽。</p>
<p>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈冢分配多大的局部变量空间时完全确定的。在方法运行期间不会改变局部变量表的槽的数量。</p>
<p><strong>异常状况</strong>：</p>
<p>在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出<code>StackOverflowError</code>异常。</li>
<li>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出<code>OutOfMemoryError</code>异常。</li>
</ul>
<p><code>HotSpot</code>虚拟机的栈容量是不可以动态扩展的，所以该虚拟机上不会出现由于虚拟机动态扩展导致的<code>OutOfMemoryError</code>d=异常。</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈(<code>native Method Stacks</code>)与虚拟机栈所发挥的非常相似，区别在于虚拟机栈为虚拟机执行Java方法服务，二笨死方法则是为虚拟机使用的本地方法服务。《Java虚拟机规范》中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制性的规定，因此具体的虚拟机可以根据需要实现它。<code>HotSpot</code>将之与虚拟机栈合二为一。本地方法栈也会在栈深度溢出或者栈扩展失败时抛出异常<code>StackOverflowError</code>与<code>OutOfMemoryError</code>异常。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>对于Java应用程序来说，Java堆(<code>java heap</code>)是虚拟机中所管理的内存中最大的一块。Java堆是被所有线程共享的一个内存区域，在虚拟机启动时创建。堆的唯一目的就是存放对象实例，Java世界里，几乎所有的对象实例都存在这篇区域。《Java虚拟机规范》中描述：所有对象实例以及数组都应该分配在堆上。不过随着技术升级，栈上分标量替换优化手段使得对象分配在堆上已经不那么绝对了。Java堆是垃圾收集器管理的内存区域。如果从分配内存的角度来看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区(<code>Thread Local Allocation Buffer</code> <strong>TLAB</strong>),以提升对象分配时的效率。Java堆可以储在内存中不连续的块中，但是逻辑上必须是连续的。主流虚拟机的堆都可以扩展。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时抛出异常<code>OutOfMemoryError</code>异常。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区(<code>Method Area</code>)是所有线程共享的。它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。《Java虚拟机规范》对方法区规范较为宽松，不要连续的物理内存区域，可以选择固定大小或者扩展，可以不用实现垃圾收集。该区域的内存回收目标主要是针对常量池的回收和类型的卸载，一般来说这个区域的回收效果难以令人满意。如果方法区无法满足新的内存分配需求时，将抛出<code>OutOfMemoryError</code>异常。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池是方法区的一部分。Class文件中除了类的版本、字段、方法、接口等信息描述，还有一项信息就是：常量池表，用于存放编译期间生成的各种字面量于符号引用，这部分内容将在类加载后存放到方法区的运行常量池中。运行时常量池相对于Class文件常量池的另一个重要特征是：具备动态性，Java语言并不要求常来给你一定只有编译器才能产生，并非预置入Class文件的常量池内容才可以进入方法区的运行时常量池，运行期间也可以将新的常量放入池中，String类的<code>intern()</code>方法用得较多。既然运行时常量池相是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时抛出<code>OutOfMemoryError</code>异常。</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。被频繁使用，可能导致<code>OutOfMemoryError</code>的异常。NIO类，引入了一种基于通道与缓冲区的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储再Java堆里的<code>DirectByteBuffer</code>对象作为这块内存的引用进行操作。避免Java堆中和native中来回复制数据。本机直接内存的分配不会受到Java堆大小的限制，但是作为内存受到本机总内存大小以及处理器寻址空间的限制。在一定情况会造成<code>OutOfMemoryError</code>异常。</p>
<h2 id="HotSpot虚拟机"><a href="#HotSpot虚拟机" class="headerlink" title="HotSpot虚拟机"></a>HotSpot虚拟机</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。<br>在类加载检查通过后，虚拟机将为新生对象分配内存。为对象分配空间的任务实际上等同于把一块确定大小的内存从Java堆中划分出来。</p>
<ul>
<li>指针碰撞：Java堆中内存绝对规整的。</li>
<li>空闲列表：Java堆中的内存零散分布，通过建立和维护空闲内存列表实现对象的空间分配。</li>
</ul>
<p>关于对象创建过程中的线程不安全问题（频繁的创建对象过程，同一地址分配多个对象导致数据的复写问题）的解决方案：</p>
<ul>
<li>堆分配内存空间的动作进行同步处理—–虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。</li>
<li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预分配一个小块内存，称为本地缓冲分配区。只有本地发缓冲区用完了，分配新的缓存区时才需要同步锁定。</li>
</ul>
<p>内存分配完成之后，虚拟机比较将分配到内存空间都初始化为零值，如果使用了TLAB的话，这一项工作提前到TLAB分配时顺便进行。这部操作保证了对象的实例字段可以不用初始化就可以直接使用，是程序能访问到这些字段的数据类型所对应的零值。<br>此外，Java虚拟机还需要对对象进行必要的设置，例如这个对象对应的类，对应类的元数据信息，对象的哈希码，对象的GC分代年龄等信息。<br>从虚拟机的角度出发，对象已经产生了，但是从程序的角度出发，对象的构造才刚刚开始，即Class文件中的<code>&lt;init&gt;()</code>方法还没有执行，所有的字段都 为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说（由字节 码流中new指令后面是否跟随<code>invokespecial</code>指令所决定，Java编译器会在遇到new关键字的地方同时生成 这两条字节码指令，但如果直接通过其他方式产生的则不一定如此），new指令之后会接着执行<code>&lt;init&gt; ()</code>方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在<code>HotSpot</code>虚拟机里，对象在堆中的存储布局可以划分三个部分：</p>
<ul>
<li>对象头(<code>Header</code>)</li>
<li>实例数据(<code>Instance data</code>)</li>
<li>对齐填充(<code>Padding</code>)</li>
</ul>
<p>对象头包含两类信息：</p>
<ul>
<li>用于存储对象自身的运行时数据，称作<code>Mark Word</code>。比如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等信息。<code>Mark Word</code>的长度和计算机的位保持一致，但对象的信息不止这么多，一般采用状态复用的方式实现多种信息的记录。</li>
<li>类型指针，也就是对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象实例属于哪个类。并不是所有的虚拟机实现都必须在对象数据上保流类型指针，查找对象的元数据信息并不一定时经过对象本身。</li>
</ul>
<p>实例数据是对象真正存储的有效信息，即对象中的各个字段的内容。包括从父类继承的字段信息以及自身定义的。信息的存储顺序会受到Java虚拟机分配策略参数与程序源码定义的顺序的影响。</p>
<p>对齐填充，不是必然存在的，它仅仅起着占位符的作用。 任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>Java程序会通过栈上的reference数据来操作堆上的具体对象。reference类型在《Java虚拟机规范》里面只规定了他是一个指向对象的引用，并没有定义这个引用如何去定位、访问到堆中的对象的具体位置，所以对象的访问方式也是由虚拟机实现而定的，主流的访问方式有使用句柄和直接指针：</p>
<ul>
<li>句柄：Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</li>
<li>直接指针：Java堆中对象的内存布局九必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果访问对象本身的话，就不需要多一次的间接访问的开销。</li>
</ul>
<p>两种方式参考下面给的两张图。</p>
<img src="/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE.PNG" class>

<img src="/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.PNG" class>

<h1 id="垃圾收集器与自动内存管理"><a href="#垃圾收集器与自动内存管理" class="headerlink" title="垃圾收集器与自动内存管理"></a>垃圾收集器与自动内存管理</h1><p>垃圾收集器需要完成的三件事：</p>
<ul>
<li>确认需要回收的内存</li>
<li>确认回收的时间</li>
<li>确认回收的方法</li>
</ul>
<h2 id="对象回收策略"><a href="#对象回收策略" class="headerlink" title="对象回收策略"></a>对象回收策略</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>算法原理：在对象中添加一个引用计数器，每当一个地方引用就<code>+1</code>，每当引用失效时，引用计数就<code>-1</code>。当计数器为零时，表示该对象已死，可回收。主流Java虚拟机并没有采用引用技术算法作为对象的回收管理算法，原因在于：引用计数算法需要额外的更多的处理保证其正确性，此外还无法解决<strong>对象之间的循环引用</strong>问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance=objB;</span><br><span class="line">        objB.instance=objA;</span><br><span class="line">        objA=<span class="keyword">null</span>;</span><br><span class="line">        objB=<span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String ...ags)</span></span>&#123;</span><br><span class="line">        ReferenceCountingGC referenceCountingGC = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        referenceCountingGC.testGC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的代码通过<code>objA.instance=objB</code>,<code>objB.instance=objA</code>;来建立对象AB之间的引用。然后并没有对AB对象进行其他的操作，如果采用引用计数算法，那么AB则无法回收。事实上，执行结果表明：对象AB确实被回收了。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>可达性分析算法是主流语言(java c#)的内存管理算法。</p>
<p>可达性分析算法的基本思路：<br>通过一系列称作<strong>GC Roots</strong>的根对象作为起始节点集。从这些节点出发，根据引用关系向下搜索，搜索过程所走过的路径叫做<strong>引用链</strong>，如果某个对象到<code>GC　Roots</code>间没有任何引用链相连，也就是图中的对象节点不可达，证明该节点不能再被使用，可被回收。</p>
<img src="/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.PNG" class>

<p>上图的对象<code>5,6,7</code>是可被回收的。</p>
<p>Java技术体系里面，固定可作为<code>GC Roots</code>的对象包括以下几种：</p>
<ul>
<li>在虚拟机栈（帧栈本地变量表）引用的对象，如各个线程被调用的方法队栈中使用的参数，局部变量，临时变量等。</li>
<li>在方法区的中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象，譬如字符串常量池里的引用。</li>
<li>在本地方法栈中JNI引用的对象。</li>
<li>Java虚拟机内部的引用，例如基本数据类型对应的Class对象，常驻异常对象，和系统类加载器。</li>
<li>所有被同步锁(<code>synchronized</code>)持有的对象。</li>
<li>反应Java虚拟机内部的JMXBean、JVMTI中注册的回调，本地代码缓存。</li>
</ul>
<p>此外，还有一些临时规定的根对象构成<code>GC Roots</code>集合的对象。在某些情况下需要，比如针对特定区域的垃圾回收，可能需要将其他区域的对象关联考虑进去，这样保证对象的回收的有效性。</p>
<h3 id="引用类型划分"><a href="#引用类型划分" class="headerlink" title="引用类型划分"></a>引用类型划分</h3><p>从JDK 1.2之后，Java对引用的概念进行了扩充，分为四类：</p>
<ul>
<li><strong>强引用</strong>：最传统的引用，是指在程序代码中普遍存在的引用赋值，无论何时，只要强引用关系还在，垃圾回收其就不会回收该对象。</li>
<li><strong>软引用</strong>：用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出前，会把这些对象列入回收范围之中进行第二次回收。如果这次回收还没有足够的内存则抛出异常。<code>SoftReference</code>实现软引用类。</li>
<li><strong>弱引用</strong>：用来描述那些非必须对象，但是它的强度比软引用更加弱一些，被弱引用关联的对象只能生存道下一次垃圾收集发生之前。当垃圾回收工作开始，无论内存容量是否足够，该类对象都会被回收。<code>WeakReference</code>实现弱引用类。</li>
<li><strong>虚引用</strong>：最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的时：为了能够在这个对象被回收时受到一个系统通知。<code>PhantomReference</code>实现虚引用类。</li>
</ul>
<h3 id="对于可回收的对象的处理"><a href="#对于可回收的对象的处理" class="headerlink" title="对于可回收的对象的处理"></a>对于可回收的对象的处理</h3><p>在可达性分析算法中被判定为死刑的对象也不是非死不可的，需要两阶段的标记过程才真正的宣判死亡。如果对象在进行可达性扽西的时候没有与GC Roots相连，会被第一次标记，然后进行一次筛选，筛选的条件是：此对象是否有必要执行<code>finalize</code>方法。假如对象没有覆盖<code>finalize</code>方法，或者<code>finalize</code>方法已经被虚拟机调用过，那么虚拟机将这两种情况视为“没必要执行”。</p>
<p>如果这个对象被判定为有必要执行<code>finalize</code>方法，那么该对象将会被放置在一个名为<code>F-Queue</code>的队列中，并在杀后由一条虚拟机自动建立的、低调度优先级的<code>Finalizer</code>线程去执行它们的<code>finalize</code>方法。该线程的执行也不一定是必须执行完成的。</p>
<p><code>F-Queue</code>队列中的<code>finalize</code>的对象不一定偏要执行自杀过程，然后收集器会对<code>F-Queue</code>做一次小规模的第二次标记。如果对象重新与引用链上的任何一个对象建立关联关系，则会被垃圾回收器抛弃，不被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;yes, i am still alive :)&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; </span><br><span class="line">        <span class="keyword">super</span>.finalize(); </span><br><span class="line">        System.out.println(<span class="string">&quot;finalize method executed!&quot;</span>); </span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123; </span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC(); <span class="comment">//对象第一次成功拯救自己 </span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>; </span><br><span class="line">        System.gc(); <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它 </span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>); </span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123; </span><br><span class="line">            SAVE_HOOK.isAlive(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;no, i am dead :(&quot;</span>); </span><br><span class="line">        &#125;<span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>; </span><br><span class="line">        System.gc(); <span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它 </span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>); </span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123; </span><br><span class="line">            SAVE_HOOK.isAlive(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            System.out.println(<span class="string">&quot;no, i am dead :(&quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finalize method executed!</span><br><span class="line">yes, i am still alive :)</span><br><span class="line">no, i am dead :(</span><br></pre></td></tr></table></figure>

<p>上述结果的解释：垃圾收集器出发<code>SAVE_HOOK</code>对象的<code>finalize()</code>方法，并且由于该方法将<code>SAVE_HOOK</code>指向对象本身，添加一次引用，使得垃圾回收放弃回收。但是第二次执行同样的代码却被回收原因在于:每个对象的<code>finalize()</code>方法只会被执行一次。第二次垃圾回收显然没有触发对象的<code>finalize()</code>方法，所以对象被回收。</p>
<h3 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h3><p>相比于Java堆中的对象的回收，方法区的回收条件变得更加苛刻。一般方法区的回收主要包括：<strong>废弃常量</strong>与<strong>不再使用的类型</strong>。废弃的常量的回收相对容易，只需要保证该常量不再被使用。如果判断一个类型是否属于<strong>不再被使用的类</strong>需要满足下列的几个条件：</p>
<ul>
<li>该类的所有实例都被回收，也就是Java对中不存在该类及其任何派生的子类的实例。</li>
<li>加载该类的类加载器已经被回收。</li>
<li>该类对应的<code>java.lang.Class</code>对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>基于上述的问题，某些Java虚拟机不在方法区实现垃圾回收机制。然而在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载 器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>分代收集理论是一套符合大多数程序运行的实际情况的经验法则，建立在两个假说基础上：</p>
<ul>
<li>弱分代假说：绝大多数的对象都是朝生夕灭的。</li>
<li>强分代假说：熬过越多次垃圾回收过程的对象越难以消亡。</li>
</ul>
<p>收集器将Java堆划分不同的区域，按照对象的年龄(熬过垃圾回收的次数)将对象进行分组存放。这样一来，对于符合若分代假说的对象都在同一片区域，可以以较低的成本对这些对象进行回收获得空间。对于符合强分代假说的区域，进行垃圾回收的频率则相应的减少。</p>
<p>基于对Java堆的划分，产生了具有针对性的垃圾回收算法，如<strong>标记-复制算法</strong>,<strong>标记-清除算法</strong>,<strong>标记-整理算法</strong>.</p>
<p>基于Java堆的划分，一般垃圾收集器的设计者将Java堆划分为新生代与老年代。对于新生代与老年代内部的对象回收相对容易，但是新生代与老年代之间的对象可能存在相互引用的情况。如果回收一个新生代的对象，根据可达性分析算法，需要遍历整个老年代区域，显然开销是比较大的，于是引入下一条假说：</p>
<ul>
<li>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</li>
</ul>
<p>上述假说的潜在意思：存在相互引用的对象的消亡史应该是一致的，采取的方案便是：新生代成长为老年代，让跨代的现象消失。</p>
<p>这里关于对Java堆的划分思想在论文《Pattern-Guided File Compression with User-Experience Enhancement for Log-Structured File System on Mobile Devices》中有着异曲同工的体现。</p>
<p><strong>标记-清除算法</strong>是最基础的垃圾回收算法。存在的缺点：当回收对象数量较大时，标记过程浪费时间以及效率下降。随着对象的回收，产生极大的内存空间碎片化问题。<strong>标记-复制算法</strong>通过将内存区域平分为两半，并且只使用其中一块，直到用完之后，将其中存活的对象复制到另一块中，然后清除内存，实现对对象的回收。存在的问题便是：如果大多数对象在使用一半内存之后存活，那么将会产生较大的复制操作，性能受到影响。事实上，大多数对象熬不过一轮，也就是说，基本大多数对象会在内存满之后死掉，这也就为该方法带来了实际的利益。显然，该算法适合新生代的对象，对于老年代对象，显然有些吃力。为了解决<strong>标记-复制算法</strong>在大多数对象存活情况下的复制开销问题，提出了<strong>标记-整理算法</strong>，其基本步骤:让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存.通常为了合理的提升性能，减少开销，可能不止使用一种算法。</p>
<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p>实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不与包括Java语言在内的任何程序语言绑定，他只与Class文件这种特定的二进制文件格式关联。Class文件种包含了虚拟机指令集，符号表以及若干其他辅助信息。</p>
<h2 id="类文件结构-1"><a href="#类文件结构-1" class="headerlink" title="类文件结构"></a>类文件结构</h2><p>Class文件是一组以8字节为基本单位的二进制流。各个数据项目严格按照顺序排列在文件之中，中间没有添加任何分隔符。当遇到大于8字节的整体数据，则通过高字节在前面进行排列。Class的文件格式采取与C语言类似的结构体的伪结构体，只有两种类型：无符号数与表。</p>
<ul>
<li>无符号数：属于基本数据类型，用<code>u1</code>,<code>u2</code>,<code>u4</code>,<code>u8</code>表示1字节、2字节、4字节和8字节的无符号数，无符号数可以描述数字，索引引用，数值量和按照UTF-8编码的构成的字符串值。</li>
<li>表：由多个无符号数或者其他数据结构表构成的符合数据结构。表名一般以<code>_info</code>为名。</li>
</ul>
<p>为了表示类型相同但是数量不定的数据结构时，通常前置容量计数器与数据区域构成整个数据区。这样的数据称为“集合”。</p>
<p><strong>魔数与版本号</strong><br>每个Class文件的头四字节都是一个魔数，表示该Class文件是否被虚拟机接受的标识。接下来的四个字节标识Class文件的版本号：</p>
<ul>
<li>第<code>5</code>,<code>6</code>字节表示次版本号。</li>
<li>第<code>7</code>,<code>8</code>字节表示主版本号。</li>
</ul>
<p>采取向前兼容版本号，根本JDK的版本，后面发行的JDK肯定支持前面发行的版本号的代码。</p>
<p><strong>常量池</strong><br>接着主次版本号的2字节就是常量池的入口地址，常量池可以比喻为Class文件的资源仓库。常量池是Class文件与其他项目关联最多的数据，通常也是占用Class文件最多的数据。由于常量池的数量不确定，所以常量池入口需要放置u2类型的数据，代表常量池容量的数据(<code>constant_pool_count</code>).<br>常量池主要存放两类数据：</p>
<ul>
<li><p>字面量(<code>Literal</code>):接近Java语言的常量概念，文本字符串，被声明为final的常量值。</p>
</li>
<li><p>符号引用(<code>Symbolic Reference</code>)：属于编译原理方面的概念，主要包括以下几类：</p>
<ul>
<li>被模块导出或者开放的包(<code>Package</code>)。</li>
<li>类和接口的全限定名(<code>Fully Qualified Name</code>) 。</li>
<li>字段名称和描述符(<code>Descriptor</code>)。</li>
<li>方法名称和描述符。</li>
<li>方法句柄和方法类型。</li>
<li>动态调用点和动态常量。</li>
</ul>
</li>
</ul>
<p><strong>Java代码在Javac编译的时候，不会保存各个方法，字段的最终物理地址，只有在程序运行期间才真正的获得。Java虚拟机加载类时候，将从常量池种获得相应的符号引用，再在类创建或者运行的时候解析和编译到具体的地址。</strong></p>
<p>常量池中的每一项常量都是一个表，分别由17种表来表示：</p>
<img src="/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%A1%A8.PNG" class>

<p><strong>访问标识符</strong>：<br>接着常量池的字段就是访问标志(<code>access_flags</code>)。访问标志用于识别一些类和接口层次的访问信息，包括：</p>
<ul>
<li>类别（接口还是类）</li>
<li>访问权限（public或者其他）</li>
<li>抽象与否（<code>abstract</code>)</li>
</ul>
<p>访问标志一共有16个标志可以使用，没有应用到的标志默认为0.</p>
<p>访问标志的具体信息参考如下：</p>
<img src="/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E7%AC%A6.PNG" class>

<p><strong>类索引、父类索引、接口索引集合</strong>:<br>类索引和父类索引都是一个u2类型的数据，而接口索引集合则是一组u2类型的数据的集合。Class文件通过这三个来确定类的继承的关系。类索引用于确定这类的全限定名。父类索引用于确定这类的父类的全限定名。类索引，父类索引，接口索引集合都按照顺序排列在访问标志之后，类索引，父类索引用两个u2类型的索引值表示，各自指向一个为<code>CONSTANT_Class_info</code>类常量描述符。</p>
<h1 id="虚拟机类加载机制-加载子系统"><a href="#虚拟机类加载机制-加载子系统" class="headerlink" title="虚拟机类加载机制(加载子系统)"></a>虚拟机类加载机制(加载子系统)</h1><p>Java虚拟机把描述类的数据从Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程叫做虚拟机的类加载机制。与编译器间需要连接的程序不同，Java语言里面，类的加载、连接和初始化过程都是程序运行器间完成的。Java天生可以动态扩展的语言特性就是依赖运行器期动态加载和动态连接这个特点实现的。</p>
<img src="/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%9E%B6%E6%9E%84.PNG" class>

<p>上图展示加载子系统的位置，具体的过程参考如下的图片：</p>
<img src="/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B.png" class>

<p>类加载器子系统负责从文件系统或者网络中加载class文件。ClassLoader只负责class文件的加载，是否能运行则由Execution Engine决定。加载的信息放入方法区。</p>
<h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>一个类型从被加到到虚拟机内存中开始，到卸载出内存为止，它的整个声明周期将会经历加载(<code>loading</code>)、验证(<code>Verification</code>)、准备(<code>Preparation</code>)、解析(<code>Resolution</code>)、初始化(<code>Initialization</code>)、使用(<code>using</code>)和卸载(<code>Unloading</code>)七个阶段。</p>
<img src="/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%91%A8%E6%9C%9F.PNG" class>

<p>上图中，加载、验证、准备、初始化和卸载这几个阶段的顺序是完全确定的，类型的加载必须按照这个顺序来按部就班开始，而解析则不一定：解析在某些情况下，可以在初始化之后再开始，这是为了支持Java语言运行时绑定特性。</p>
<p>对于初始化阶段，《Java虚拟机规范》严格规定了有且只有六种情况必须立即对类进行初始化：</p>
<ol>
<li><p>遇到new、getstatic,putstatic或者invokestatic这四条指令时，如果类型没有进行初始化，则需要先触发其初始化阶段。能够生成四条指令的典型Java场景：</p>
<ul>
<li>使用new关键字实例化对象的时候</li>
<li>读取或者设置一个类型的静态字段（被final修饰、已在编译期间把结果放入常量池的静态字段除外）的时候。</li>
<li>调用一个类型的静态方法的时候。</li>
</ul>
</li>
<li><p>使用<code>java.lang.reflect</code>包的方法对类型机型反射调用的时候，如果类型没有进行初始化，则需要先触发其初始化。</p>
</li>
<li><p>当初始化类的时候，如果发现其父类还没有进行初始化，则需要先触发父类的初始化。</p>
</li>
<li><p>当虚拟机启动时，用户需要执行一个要执行的主类，虚拟机先初始化这个类。</p>
</li>
<li><p>当使用JDK7新加入的动态语言支持时，如果使用<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果为<code>REF_getStatic</code>,<code>REF_putStatic</code>,<code>REF_invokeStatic</code>,<code>REF_newInvokeSpecial</code>四种类型的方法句柄，并且这个方法句柄对应的类型还没有进行初始化，则需要先触发器初始化。</p>
</li>
<li><p>当接口定义了一个JDK8 的默认方法，如果由这个接口的实现类发生了初始化，那该接口要在其之前进行初始化。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 被动使用类字段演示一： </span></span><br><span class="line"><span class="comment">* 通过子类引用父类的静态字段，不会导致子类初始化 </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;SuperClass init!&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;SubClass init!&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 非主动使用类字段演示 </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        System.out.println(SubClass.value); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的代码运行结果是：<code>SuperClass init!</code>,不会触发<code>SubClass</code>的初始化，只会触发<code>SuperClass</code>的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 被动使用类字段演示二： </span></span><br><span class="line"><span class="comment">* 通过数组定义来引用类，不会触发此类的初始化 </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        SuperClass[] sca = <span class="keyword">new</span> SuperClass[<span class="number">10</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的代码没有输出<code>SuperClass init!</code>.<br>下面的代码跟不会输出<code>SuperClass init!</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">       System.out.println(SuperClass.value);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>加载阶段，<strong>Java虚拟机需要完成三件事情</strong>：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存种生成一个代表这个类的<code>java.lang.Class</code>对象，作为放啊发去这个类的各种数据的访问入口。</li>
</ol>
<p>关于上述中提到的二进制字节流的获取并没有明确规定只能从class文件中获取，所以提供了一个灵活的实现方式的前提，通常有以下几种获取二进制字节流的方式：</p>
<ol>
<li>class文件中</li>
<li>从ZIP压缩包中读取，典型的JAR</li>
<li>从网络中获取，比如Web Applet</li>
<li>运行时环境中动态代理生成。</li>
<li>专有数据库</li>
<li>加密文件等</li>
<li>……</li>
</ol>
<p>对于非数组类型的二进制字节流，其加载是相对自由的，实现其加载的加载器可以是虚拟机内置类引导加载器，也可以是程序员自定义的加载器（重写一个类加载器的findClass()或loadClass()方法）.对于数组类型，数组类型本身不能被类加载器加载，它是由Java虚拟机直接在 内存中动态构造出来的。但是数组除去所有维度最后的元素类型还是需要通过类加载器实现加载。<br>数组类型创建过程如下：</p>
<ol>
<li>如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型，注意和前面的元素类 型区分开来）是引用类型，那就递归加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上。</li>
<li>如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C标记为与引导类加载器关联。</li>
<li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的 可访问性将默认为public，可被所有的类和接口访问到。</li>
</ol>
<p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中。方法区中的数据存储格式完全由虚拟机实现自行定义。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象， 这个对象将作为程序访问方法区中的类型数据的外部接口。<br>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段 尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚 拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。<br>验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节 码验证和符号引用验证。<br><strong>文件格式验证</strong>：<br>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶 段可能包括下面这些验证点： </p>
<ul>
<li>是否以魔数0xCAFEBABE开头。 </li>
<li>主、次版本号是否在当前Java虚拟机接受范围之内。 </li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。 </li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 </li>
<li>CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。 </li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li>
<li>……</li>
</ul>
<p><strong>元数据验证</strong>：<br>第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要 求，这个阶段可能包括的验证点如下： </p>
<ul>
<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。 </li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。 </li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。 </li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方 法重载，例如方法参数都一致，但返回值类型却不同等）。 </li>
<li>……</li>
</ul>
<p><strong>字节码验证</strong>：<br>第三阶段主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为，例如： </p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作 栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。 </li>
<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。 </li>
<li>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全 的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。</li>
</ul>
<p><strong>引用符号的验证</strong>：<br>该阶段发生在虚拟机将符号引用转化为直接引用的时候。符号引用验证可以看作是对类自身以外（常量池中的各种符号 引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部 类、方法、字段等资源。本阶段通常需要校验下列内容： </p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。 </li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。 </li>
<li>符号引用中的类、字段、方法的可访问性（<code>private、protected、public、&lt;package&gt;</code>）是否可被当 前类访问。</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类中定义的变量分配内存被那个设置初始值的阶段，从概念上讲，这些变量所使用的内存都应该在方法区进行分配，但必须注意到方法区本身是一个逻辑上的区域。JDK8之后，类变量则会随着Class对象一起存放在Java堆中。<br>进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> number=<span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>上述代码在准备阶段后只会被初始化为0，此时还未执行任何java方法，而把value赋值为123的<code>putstatic</code>指令是程序被编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中，所以把value赋值为123的动作要到类的初始化阶段才会被执行.而对于final类型的数据，一般在数据准备时直接完成赋值操作。准备阶段，一般情况复制情况如下：</p>
<img src="/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%E5%A4%8D%E5%88%B6%E6%83%85%E5%86%B5.PNG" class>

<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段时Java虚拟机讲常量池内的符号引用替换为直接引用的过程，符号引用在Class文件中它以<code>CONSTANT_Class_info</code>,<code>CONSTANT_Fieldref_info</code>,<code>CONSTANT_Methodref_info</code>等类型的常量出现，那解析阶段中所说的直接引用的关联如下：</p>
<ul>
<li><strong>符号引用</strong>：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用和虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存中的内容。</li>
<li><strong>直接引用</strong>：直接引用是可以直接指向目标的指针，相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机内存布局直接相关的，统一符号引用在不同虚拟机实力上翻译出来的直接引用一般不相同。如果有了直接引用，那引用的目标必定已经存在在虚拟机的内存中。</li>
</ul>
<p>《Java虚拟机规范》并未规定解析阶段的具体实践，只要求了在执行<code>ane-warray</code>、<code>checkcast</code>,<code>getfield</code>,<code>getstatic</code>,<code>instanceof</code>,<code>invokedynamic</code>,<code>invokeinterface</code>,<code>invoke-special</code>,<code>invokestatic</code>,<code>invokevirtual</code>,<code>ldc</code>,<code>ldc_w</code>,<code>ldc2_w</code>,<code>multianewarray</code>,<code>new</code>,<code>putfield</code>,<code>putstatic</code>这17个用于操作符号引用的字节码指令之前，先对他们所用的符号引用进行解析。</p>
<p>解析动作主要针对类或者接口，字段，类方法，方法类型，方法句柄和调用点限定符这7类符号引用进行，分别对应于常量池中的<code>CONSTANT_Class_info</code>,<code>CONSTANT_Fieledref_info</code>,<code>CONSTANT_Methodref_info</code>,<code>CONSTANT_InterfaceMethodref_info</code>,<code>CONSTANT_MethodType_info</code>,<code>CONSTANT_MethodHandle_info</code>,<code>CONSTANT_Dynamic_info</code>和<code>CONSTANT_InvokeDynamic_info</code>8种常量类型。</p>
<p>对于静态指令，一般通过一次解析，如果第一次解析成功，那么代表后来的解析也是成功的，如果第一次解析失败，那么后面的解析也会导致失败。而对于<code>invokedynamic</code>动态指令，其目的本来就是实现动态解析，只有运行时出现该条指令时才执行解析操作。</p>
<p><strong>类或者接口的解析</strong>：<br>假设当前代码所在的类为D，如果把一个从未解析的符号引用N解析为一个类或者接口C的直接引用，那虚拟机完整解析过程需要如下几个过程：</p>
<ol>
<li>如果C不是一个数组类新给，那么虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证，字节码验证的需要，又可能触发其他类的加载动作，一旦加载过程出现了任何异常，解析过程宣告失败。</li>
<li>如果类C是一个数组类型，并且数组的元素类型为对象，也就是N的描述会是类似[Ljava/lang/Integer]的形式，那将会按照第一点的规则加载数组元素类型。如果N的描述符如前所假设的形式，需要加载的元素类型就是<code>java.lang.Integer</code>，接着由虚拟机生成一个代表该数组维度和元素的数组对象。</li>
<li>如果上述两步没有出现异常，那么C在虚拟机中实际上已经成为了一个有效的类或者接口了，但在解析完成前还要进行符号引用验证，确认D是否具备C的访问权限。如果发现不具备访问权限，将抛出<code>java.lang.IllegalAccessError</code>异常。</li>
</ol>
<p><strong>字段解析</strong>：<br>要解析一个未被解析过的字段符号引用，首先将会对字段表内<code>class_index</code>项中索引的<code>CONSTANT_Class_info</code>符号引用进行解析，也就是字段所属类的符号引用。如果在解析这个类或者接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析失败。如果解析成功完成，那么这个字段所属的类或者接口用C表示，《Java虚拟机规范》要求按照如下的步骤进行后续字段的搜索：</p>
<ol>
<li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果在C中实现了接口，将会按照继承关系从上往下递归搜索各个接口和它的父类接口，如果接口中包含了简单名称和描述符都与目标相匹配，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果C不是<code>java.lang.Object</code>，将会按照继承关系从上往下进行搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配，则返回这个字段的直接引用，查找结束。</li>
<li>否则，查找失败，抛出<code>java.lang.NoSuchFieldError</code>异常。</li>
</ol>
<p><strong>方法解析</strong>：<br>解析过程需要先解析出方法表的<code>class_index</code>项中索引的方法所属的类或者接口的符号引用，如果解析成功，那么我们依然用表示这个类，接下来虚拟机将会按照如下的步骤进行后续的搜索：</p>
<ol>
<li>由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现<code>class_index</code>中索引的C是个接口的话，那就直接抛出<code>java.lagn.IncompatibleChangeError</code>异常。</li>
<li>如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，结束查找，</li>
<li>否则，在类C的父类中继续2的过程。</li>
<li>否则，在类C的实现的接口中继续2的过程。</li>
<li>否则，抛出<code>java.lang.NoSuchMethodError</code>异常。</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类的初始化阶段是类加载过程的最后一个步骤，直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权以交给应用程序。进行准备阶段，变量已经赋值过一次系统要求的0值，而在初始化阶段，则会根据程序员通过程序编码定制的主观计划去初始化类变量和其他资源。</p>
<p>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。<code>&lt;clinit&gt;()</code>并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物.<code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（<code>static&#123;&#125;</code>块）中的 语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        i = <span class="number">0</span>; <span class="comment">// 给变量复制可以正常编译通过 </span></span><br><span class="line">        System.out.print(i); <span class="comment">// 这句编译器会提示“非法向前引用” </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;clinit&gt;()</code>方法与类的构造函数（即在虚拟机视角中的实例构造器<code>&lt;init&gt;()</code>方法）不同，它不需要显 式地调用父类构造器，Java虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行前，父类的<code>&lt;clinit&gt;()</code>方法已经执行 完毕。因此在Java虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类型肯定是<code>java.lang.Object</code>。<br>由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值 操作，如下面代码的字段B的值将会是2而不是1.</clinit></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> SuperClass&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        A=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> SubClass extends SuperClass&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> B=A;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String ... args)</span></span>&#123;</span><br><span class="line">        System.out.println(SubClass.B);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;clinit&gt;()</code>方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的 赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code>方法。 </p>
<p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 <code>&lt;clinit&gt;()</code>方法。但接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法， 因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也 一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。 </p>
<p>Java虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁同步，如果多个线程同 时去初始化一个类，那么只会有其中一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等 待，直到活动线程执行完毕<code>&lt;clinit&gt;()</code>方法。如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，那就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的.</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>把“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类的动作的实现代码被称作：**类加载器(Class Loader)**。</p>
<p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每 一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相 等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。下面的代码可以充分说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123; </span><br><span class="line">            <span class="meta">@Override</span> </span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123; </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>)+<span class="string">&quot;.class&quot;</span>; </span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName); </span><br><span class="line">                    <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123; </span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name); </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()]; </span><br><span class="line">                    is.read(b); </span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length); </span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) &#123; </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;;</span><br><span class="line">        Object obj = myLoader.loadClass(<span class="string">&quot;org.fenixsoft.classloading.ClassLoaderTest&quot;</span>).newInstance(); System.out.println(obj.getClass()); </span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> org.fenixsoft.classloading.ClassLoaderTest); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的代码的运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class org.fenixsoft.classloading.ClassLoaderTest </span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>最后的<code>false</code>结果表明，两个ClassLoaderTest类的实例对象利用<code>instanceof</code>判断为false。原因在于：一个是利用Java虚拟机的类加载器得到的实例，另一个是我们自定义的类加载器得到的实例，基于同一类加载器的前提，判断为false理所当然。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（<code>Bootstrap ClassLoader</code>），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是其他所有 的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类<code>java.lang.ClassLoader</code>。</p>
<p>启动类加载器（<code>Bootstrap Class Loader</code>）:这个类加载器负责加载存放在 <JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可.</JAVA_HOME></p>
<p>扩展类加载器（<code>Extension Class Loader</code>）:这个类加载器是在类<code>sun.misc.Launcher$ExtClassLoader</code>中以Java代码的形式实现的。它负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所 指定的路径中所有的类库。由于扩展类加载器是由Java代码实现的，开发者可以直接在程序中使用扩展类加载器来加载Class文件。</p>
<p>应用程序类加载器（<code>Application Class Loader</code>）：这个类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现。由于应用程序类加载器是<code>ClassLoader</code>类中的<code>getSystem- ClassLoader()</code>方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径 （<code>ClassPath</code>）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<img src="/blog/2021/04/11/JVM%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" class>

<p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（<code>Inheritance</code>）的关系来实现的，而是通常使用组合（<code>Composition</code>）关系来复用父加载器的代码。</p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加 载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的 加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请 求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p>
<p><strong>使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是Java中的类随着它的类 加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一 个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类 在程序的各种类加载器环境中都能够保证是同一个类。反之，如果没有使用双亲委派模型，都由各个 类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的 ClassPath中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应 用程序将会变得一片混乱。</strong></p>
<p>双亲委派模型的源代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">     <span class="comment">// 首先，检查请求的类是否已经被加载过了 </span></span><br><span class="line">    Class c = findLoadedClass(name);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123; </span><br><span class="line">                c = parent.loadClass(name, <span class="keyword">false</span>); </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                c = findBootstrapClassOrNull(name); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// 如果父类加载器抛出ClassNotFoundException </span></span><br><span class="line">            <span class="comment">// 说明父类加载器无法完成加载请求 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 在父类加载器无法加载时 </span></span><br><span class="line">            <span class="comment">// 再调用本身的findClass方法来进行类加载 </span></span><br><span class="line">            c = findClass(name); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolve) &#123; </span><br><span class="line">        resolveClass(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双亲委派模型并不是强制的，根据在某些情况下，需要破坏双亲委派模型才能达到我们的目的。</p>
<ol>
<li><p>基础类型之所以被 称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变 的完美规则，如果有基础类型又要调用回用户的代码，则需要破坏双亲委派模型才可以。典型的例子就是：<strong>JNDI服务</strong>，它通过<strong>线程上下文加载器(<code>Thread Context ClassLoader</code>)</strong>,这个类加载器可以通过<code>java.lang.Thread</code>类的<code>setContext-ClassLoader()</code>方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内 都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
</li>
<li><p>实现程序的动态性，典型的例子就是：OSGi通过类加载器实现热部署。OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为 Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实 现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更 加复杂的网状结构，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p>
<ul>
<li>将以java.*开头的类，委派给父类加载器加载。 </li>
<li>否则，将委派列表名单内的类，委派给父类加载器加载。 </li>
<li>否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。 </li>
<li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。 </li>
<li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器 加载。</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ul>
</li>
</ol>
<p>上面的查找顺序中只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的。</p>
<h3 id="Java模块化系统"><a href="#Java模块化系统" class="headerlink" title="Java模块化系统"></a>Java模块化系统</h3><p>待更新</p>
<h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><p>所有的Java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处 理过程是字节码解析执行的等效过程，输出的是执行结果。至于具体的实现方式，包括解释执行与编译执行由虚拟机的实现决定。</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>Java是一门面向对象的程序语言，因为Java具备面向对象的3个基本特征：继承、封装 和多态。<strong>分派调用过程</strong>将会揭示多态性特征的一些最基本的体现，如“重载”和“重写”在 Java虚拟机之中是如何实现的。</p>
<p><strong>静态分派</strong>：<br>在编译期间就确定执行版本的指派方法。<br>首先来一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;hello,guy!&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;hello,gentleman!&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;hello,lady!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        Human man = <span class="keyword">new</span> Man(); </span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman(); </span><br><span class="line">        StaticDispatch sr = <span class="keyword">new</span> StaticDispatch(); </span><br><span class="line">        sr.sayHello(man); </span><br><span class="line">        sr.sayHello(woman); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上述的代码提出下面几个概念：</p>
<ol>
<li>静态类型：又称外观类型，上述代码中<code>Human man=new Man()</code>.man的静态类型为<code>Human</code>。</li>
<li>实际类型：又称运行时类型，上述代码中<code>Human man=new Man()</code>.man的实际类型为<code>Man</code>。</li>
</ol>
<p><strong>静态类型和实际类型在程序中都可能会发生变化，区别是静态类型的变化仅仅 在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类 型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么</strong>。</p>
<p>虚拟机（或者准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。由于静态类型在编译期可知，所以在编译阶段，Javac编译器就根据参数的静态类型决定了会使用哪个重载版本.<br>所以上述的代码的运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello,guy! </span><br><span class="line">hello,guy!</span><br></pre></td></tr></table></figure>
<p>为了更加清晰的看到上述的代码运行过程，我们将其字节码反编译得到如下的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticDispatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(StaticDispatch.Human var1)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,guy!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(StaticDispatch.Man var1)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,gentleman!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(StaticDispatch.Woman var1)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,lady!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">        StaticDispatch.Man var1 = <span class="keyword">new</span> StaticDispatch.Man();</span><br><span class="line">        StaticDispatch.Woman var2 = <span class="keyword">new</span> StaticDispatch.Woman();</span><br><span class="line">        StaticDispatch var3 = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        <span class="comment">//静态类型指定</span></span><br><span class="line">        var3.sayHello((StaticDispatch.Human)var1);</span><br><span class="line">        var3.sayHello((StaticDispatch.Human)var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">StaticDispatch</span>.<span class="title">Human</span> </span>&#123;</span><br><span class="line">        Woman() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">StaticDispatch</span>.<span class="title">Human</span> </span>&#123;</span><br><span class="line">        Man() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">        Human() &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且当javac编译器能匹配的方法不止一个时，通常选择一个更加合适的，这也暗示了程序员在编写方法时尽量减少模糊性。</p>
<p><strong>动态分派</strong>：<br>本质：在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。<br>先看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123; </span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            System.out.println(<span class="string">&quot;man say hello&quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123; </span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            System.out.println(<span class="string">&quot;woman say hello&quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        Human man = <span class="keyword">new</span> Man(); </span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman(); </span><br><span class="line">        man.sayHello(); </span><br><span class="line">        woman.sayHello(); </span><br><span class="line">        man = <span class="keyword">new</span> Woman(); </span><br><span class="line">        man.sayHello(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码就是Java中经典的多态的例子。运行结果不言而喻如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">man say hello</span><br><span class="line">woman say hello</span><br><span class="line">woman say hello</span><br></pre></td></tr></table></figure>
<p>为了清晰看到代码执行的过程，我们使用<code>javap -verbose</code>得到下面的结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">Classfile /E:/Alearning/javademo/src/DynamicDispatch.class</span><br><span class="line">  Last modified <span class="number">2021417</span>; size <span class="number">542</span> bytes</span><br><span class="line">  MD5 checksum 7bcf508b2539043ef8bebd0b1f78f4f0</span><br><span class="line">  Compiled from <span class="string">&quot;DynamicDispatch.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">55</span></span><br><span class="line">  flags: (<span class="number">0x0021</span>) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #7                          // DynamicDispatch</span><br><span class="line">  super_class: #8                         // java/lang/Object</span><br><span class="line">  interfaces: <span class="number">0</span>, fields: <span class="number">0</span>, methods: <span class="number">2</span>, attributes: <span class="number">3</span></span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #8.#23         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #24            // DynamicDispatch$Man</span><br><span class="line">   #3 = Methodref          #2.#23         // DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #4 = Class              #25            // DynamicDispatch$Woman</span><br><span class="line">   #5 = Methodref          #4.#23         // DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #6 = Methodref          #12.#26        // DynamicDispatch$Human.sayHello:()V</span><br><span class="line">   #7 = Class              #27            // DynamicDispatch</span><br><span class="line">   #8 = Class              #28            // java/lang/Object</span><br><span class="line">   #9 = Utf8               Woman</span><br><span class="line">  #10 = Utf8               InnerClasses</span><br><span class="line">  #11 = Utf8               Man</span><br><span class="line">  #12 = Class              #29            // DynamicDispatch$Human</span><br><span class="line">  #13 = Utf8               Human</span><br><span class="line">  #14 = Utf8               &lt;init&gt;</span><br><span class="line">  #15 = Utf8               ()V</span><br><span class="line">  #16 = Utf8               Code</span><br><span class="line">  #17 = Utf8               LineNumberTable</span><br><span class="line">  #18 = Utf8               main</span><br><span class="line">  #19 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #20 = Utf8               SourceFile</span><br><span class="line">  #21 = Utf8               DynamicDispatch.java</span><br><span class="line">  #22 = Utf8               NestMembers</span><br><span class="line">  #23 = NameAndType        #14:#15        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #24 = Utf8               DynamicDispatch$Man</span><br><span class="line">  #25 = Utf8               DynamicDispatch$Woman</span><br><span class="line">  #26 = NameAndType        #30:#15        // sayHello:()V</span><br><span class="line">  #27 = Utf8               DynamicDispatch</span><br><span class="line">  #28 = Utf8               java/lang/Object</span><br><span class="line">  #29 = Utf8               DynamicDispatch$Human</span><br><span class="line">  #30 = Utf8               sayHello</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DynamicDispatch</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">1</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #2                  // class DynamicDispatch$Man</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #3                  // Method DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         8: new           #4                  // class DynamicDispatch$Woman</span><br><span class="line">        <span class="number">11</span>: dup</span><br><span class="line">        12: invokespecial #5                  // Method DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        <span class="number">15</span>: astore_2</span><br><span class="line">        <span class="number">16</span>: aload_1                            <span class="comment">//将对象Man对象压栈，作为执行hellsay方法的执行者，也叫“接收者”</span></span><br><span class="line">        17: invokevirtual #6                  // Method DynamicDispatch$Human.执行方法sayHello:()V</span><br><span class="line">        <span class="number">20</span>: aload_2                           <span class="comment">//与16行一样。</span></span><br><span class="line">        21: invokevirtual #6                  // Method DynamicDispatch$Human.sayHello:()V</span><br><span class="line">        24: new           #4                  // class DynamicDispatch$Woman</span><br><span class="line">        <span class="number">27</span>: dup</span><br><span class="line">        28: invokespecial #5                  // Method DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        <span class="number">31</span>: astore_1</span><br><span class="line">        <span class="number">32</span>: aload_1</span><br><span class="line">        33: invokevirtual #6                  // Method DynamicDispatch$Human.sayHello:()V</span><br><span class="line">        <span class="number">36</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">16</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">20</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">24</span></span><br><span class="line">        line <span class="number">22</span>: <span class="number">32</span></span><br><span class="line">        line <span class="number">23</span>: <span class="number">36</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;DynamicDispatch.java&quot;</span></span><br><span class="line">NestMembers:</span><br><span class="line">  DynamicDispatch$Woman</span><br><span class="line">  DynamicDispatch$Man</span><br><span class="line">  DynamicDispatch$Human</span><br><span class="line">InnerClasses:</span><br><span class="line">  static #9= #4 of #7;                    // Woman=class DynamicDispatch$Woman of class DynamicDispatch</span><br><span class="line">  static #11= #2 of #7;                   // Man=class DynamicDispatch$Man of class DynamicDispatch</span><br><span class="line">  static abstract #13= #12 of #7;         // Human=class DynamicDispatch$Human of class DynamicDispatch</span><br></pre></td></tr></table></figure>
<p>上述代码中主方法中显示两个对象的执行方法依然是<code>Method DynamicDispatch$Human.</code>，不能看出动态分派的结果，为了解释清楚，我们需要了解指令<code>invokevirtual</code>本身。<br>invokevirtual指令的运行时解析过程大致分为以下几步：</p>
<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。 </li>
<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalAccessError异常。 </li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>
</ol>
<p>正是因为<code>invokevirtual</code>指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的 <code>invokevirtual</code>指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，这个过程就是Java语言中方法重写的本质。</p>
<p>为了深刻理解静态分派与动态分派，有下面及其恶劣的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHasNoPolymorphic</span> </span>&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> money = <span class="number">1</span>; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            money = <span class="number">2</span>; showMeTheMoney(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMeTheMoney</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            System.out.println(<span class="string">&quot;I am Father, i have $&quot;</span> + money); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123; </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> money = <span class="number">3</span>; <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            money = <span class="number">4</span>;</span><br><span class="line">            showMeTheMoney(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMeTheMoney</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            System.out.println(<span class="string">&quot;I am Son, i have $&quot;</span> + money); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        Father guy = <span class="keyword">new</span> Son(); </span><br><span class="line">        System.out.println(<span class="string">&quot;This gay has $&quot;</span> + guy.money); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I am Son, i have $0</span><br><span class="line">I am Son, i have $4</span><br><span class="line">This gay has $2 </span><br></pre></td></tr></table></figure>
<p>结果解释：<br>根据动态分派，显然会调用<code>Son</code>的<code>showMeTheMoney()</code>方法，但是第一次输出的时候，<code>guy</code>的初始化还没结束，此时成员变量自然还是<code>0</code>.当结束初始化时，此时成员变量已经变成<code>4</code>.而最后通过静态分派访问变量，指定的是<code>Father</code>类中的成员变量，自然为<code>2</code>.</p>
<p><strong>单分派与多分派</strong>：<br>方法的接收者与方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。<br>结论：</p>
<ol>
<li>Java语言的静态分派属于多分派类型。</li>
<li>Java语言的动态分派属于单分派类型。</li>
</ol>
<p><strong>Java动态语言支持</strong>：</p>
<p>JDK7增加指令<code>invokedynamic</code>支持动态特性。实现动态类型语言（<code>Dynamically Typed Language</code>）支持而进行的改进之一， 也是为JDK 8里可以顺利实现Lambda表达式而做的技术储备.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2021/04/02/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" rel="prev" title="算法基础">
      <i class="fa fa-chevron-left"></i> 算法基础
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2021/04/15/scala%E5%9F%BA%E7%A1%80/" rel="next" title="scala基础">
      scala基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-number">1.</span> <span class="nav-text">Java虚拟机</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">自动内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F"><span class="nav-number">2.1.</span> <span class="nav-text">Java内存区域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">2.1.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">2.1.2.</span> <span class="nav-text">Java虚拟机栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-number">2.1.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%A0%86"><span class="nav-number">2.1.4.</span> <span class="nav-text">Java堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">2.1.5.</span> <span class="nav-text">方法区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">2.1.6.</span> <span class="nav-text">运行时常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="nav-number">2.1.7.</span> <span class="nav-text">直接内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-number">2.2.</span> <span class="nav-text">HotSpot虚拟机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">2.2.1.</span> <span class="nav-text">对象的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">2.2.2.</span> <span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="nav-number">2.2.3.</span> <span class="nav-text">对象的访问定位</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">垃圾收集器与自动内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="nav-number">3.1.</span> <span class="nav-text">对象回收策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="nav-number">3.1.1.</span> <span class="nav-text">引用计数算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-number">3.1.2.</span> <span class="nav-text">可达性分析算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%88%92%E5%88%86"><span class="nav-number">3.1.3.</span> <span class="nav-text">引用类型划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E5%8F%AF%E5%9B%9E%E6%94%B6%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">3.1.4.</span> <span class="nav-text">对于可回收的对象的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="nav-number">3.1.5.</span> <span class="nav-text">方法区的回收</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">垃圾收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA"><span class="nav-number">3.2.1.</span> <span class="nav-text">分代收集理论</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">类文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84-1"><span class="nav-number">4.1.</span> <span class="nav-text">类文件结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-number">5.</span> <span class="nav-text">虚拟机类加载机制(加载子系统)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA"><span class="nav-number">5.1.</span> <span class="nav-text">类加载时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">5.2.</span> <span class="nav-text">类加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD"><span class="nav-number">5.2.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-number">5.2.2.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87"><span class="nav-number">5.2.3.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90"><span class="nav-number">5.2.4.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">5.2.5.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">5.3.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.3.1.</span> <span class="nav-text">双亲委派模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F"><span class="nav-number">5.3.2.</span> <span class="nav-text">Java模块化系统</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="nav-number">6.</span> <span class="nav-text">虚拟机字节码执行引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="nav-number">6.1.</span> <span class="nav-text">方法调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%B4%BE"><span class="nav-number">6.1.1.</span> <span class="nav-text">分派</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="RockCohen"
      src="/blog/images/hugo.png">
  <p class="site-author-name" itemprop="name">RockCohen</p>
  <div class="site-description" itemprop="description">a programmer</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/rockcohen" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;rockcohen" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xluo0616@gmail.com" title="E-Mail → mailto:xluo0616@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RockCohen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  















  

  

</body>
</html>
