<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rockcohen.gitee.io","root":"/blog/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="Docker基础">
<meta property="og:url" content="https://rockcohen.gitee.io/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Rock Cohen">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/%E7%A7%91%E6%AF%94.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8%E6%80%BB%E6%9E%B6%E6%9E%84%E5%9B%BE.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/%E6%97%A7%E7%89%88%E6%9C%ACDocker%E6%9E%B6%E6%9E%84.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/Docker%E5%BC%95%E6%93%8E%E7%9A%84%E6%9E%B6%E6%9E%84.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/%E8%99%9A%E6%8B%9F%E6%9C%BA-4%E4%B8%AA%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/%E5%88%92%E5%88%864%E4%B8%AA%E5%AE%B9%E5%99%A8.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8%E5%8C%96%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/swarm%E6%9E%B6%E6%9E%84.jpg">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/%E4%B8%89%E5%B1%82%E5%85%B3%E7%B3%BB.PNG">
<meta property="article:published_time" content="2021-03-23T15:50:27.000Z">
<meta property="article:modified_time" content="2021-04-03T08:49:03.523Z">
<meta property="article:author" content="RockCohen">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rockcohen.gitee.io/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/%E7%A7%91%E6%AF%94.PNG">

<link rel="canonical" href="https://rockcohen.gitee.io/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Docker基础 | Rock Cohen</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Rock Cohen</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Cohen</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rockcohen.gitee.io/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/hugo.png">
      <meta itemprop="name" content="RockCohen">
      <meta itemprop="description" content="a programmer">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock Cohen">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Docker基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-23 23:50:27" itemprop="dateCreated datePublished" datetime="2021-03-23T23:50:27+08:00">2021-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-03 16:49:03" itemprop="dateModified" datetime="2021-04-03T16:49:03+08:00">2021-04-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <img src="/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/%E7%A7%91%E6%AF%94.PNG" class>

<span id="more"></span>
<h1 id="Part-1：docker-概览"><a href="#Part-1：docker-概览" class="headerlink" title="Part 1：docker 概览"></a>Part 1：docker 概览</h1><h2 id="chapter-1：容器发展之路"><a href="#chapter-1：容器发展之路" class="headerlink" title="chapter 1：容器发展之路"></a>chapter 1：容器发展之路</h2><ul>
<li>容器为什么出现</li>
<li>容器的作用</li>
<li>容器的应用场景</li>
</ul>
<h3 id="落后的时代"><a href="#落后的时代" class="headerlink" title="落后的时代"></a>落后的时代</h3><ul>
<li>业务是基于应用运转的。如果应用出现故障，那么业务也就无法运行。</li>
<li>大部分应用运行在服务器之上。而且一般每个服务器运行单一的应用。</li>
</ul>
<h3 id="虚拟机的出现"><a href="#虚拟机的出现" class="headerlink" title="虚拟机的出现"></a>虚拟机的出现</h3><ul>
<li>关于应用与服务器一一对应的情况的解决，是通过虚拟机来实现的。</li>
<li>虚拟机允许许多应用能够稳定、安全地运行在一个服务器上。</li>
<li>虚拟机不足：<ul>
<li>虚拟机依赖于特定地操作系统。OS会占用额外地CPU、RAM和存储等资源，这些资源本来可以运行更多地应用。此外，每个OS还需要补丁和监控</li>
<li>某些情况下，OS还需要许可证才能运行。</li>
</ul>
</li>
</ul>
<h3 id="容器的出现"><a href="#容器的出现" class="headerlink" title="容器的出现"></a>容器的出现</h3><ul>
<li>容器是为了解决虚拟机的缺点而诞生的。</li>
<li>容器的实质：<strong>轻量级虚拟化技术</strong>。</li>
<li>容器与虚拟机的区别：<ul>
<li>容器的运行不依赖于特定的操作系统，实际上，运行在相同宿主机上的容器共享一个操作系统，节省大量的系统资源。</li>
<li>容器支持快速启动。</li>
<li>容器的移植性好，不受具体的服务器的影响。</li>
</ul>
</li>
</ul>
<h3 id="Linux容器"><a href="#Linux容器" class="headerlink" title="Linux容器"></a>Linux容器</h3><ul>
<li>容器发展中重要的技术：<ul>
<li>内核命名空间（<code>kernel namespace</code>）</li>
<li>控制组(<code>Control Group</code>)</li>
<li>联合文件系统(<code>Union File System</code>)</li>
<li><code>Docker</code></li>
</ul>
</li>
</ul>
<h3 id="Windows容器"><a href="#Windows容器" class="headerlink" title="Windows容器"></a>Windows容器</h3><ul>
<li>微软实现容器所需要的核心统称为Windows容器。</li>
<li>用户空间是通过Docker来完成与Windows容器的交互的。使得在Windows上体验容器和在Linux上面是一样的。</li>
</ul>
<h3 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h3><ul>
<li>Kubernetes是Google的一个开源项目。</li>
<li>Kubernetes是保证容器部署和运行的软件体系的重要组成部分。</li>
<li>Kubernetes作为基本的容器运行时(<code>container runtime</code>).</li>
<li>Kubernetes主要应用于启动容器、停止容器以及镜像的拉取等工作。</li>
<li>Kubernetes提供一个可插拔的容器运行时接口CRI。CRI能够帮助Kubernets实现将运行时环境从Docker快速替换为其他容器运行时。</li>
<li>Kubernetes是Docker之上的一个平台，目前采用Docker实现其底层容器的相关操作。</li>
</ul>
<h2 id="chapter-2：容器基础"><a href="#chapter-2：容器基础" class="headerlink" title="chapter 2：容器基础"></a>chapter 2：容器基础</h2><ul>
<li>Docker公司</li>
<li>Docker的容器运行时和编排引擎</li>
<li>Docker的开源项目(<code>Moby</code>)</li>
</ul>
<h3 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h3><ul>
<li>Docker是一种运行于Linux于Windows上的软件，用于创建、管理和编排容器。</li>
<li>Docker是github上面开源项目<code>Moby</code>的i一部分。</li>
</ul>
<h3 id="Docker公司"><a href="#Docker公司" class="headerlink" title="Docker公司"></a>Docker公司</h3><ul>
<li>Docker起初为dotCloud的平台服务。dotCloud在底层技术上面利用了Linux容器技术。</li>
<li>Docker用于创建和管理这些相关的容器。</li>
<li><strong>Docker</strong>一词来源于英国口语，以为码头工人(<code>Dock Worker</code>):即从船上装卸货物的人。</li>
</ul>
<h3 id="Docker运行时与编排引擎"><a href="#Docker运行时与编排引擎" class="headerlink" title="Docker运行时与编排引擎"></a>Docker运行时与编排引擎</h3><ul>
<li>Docker引擎是用于运行和编排容器的基础设施工具。</li>
<li>Docker引擎是运行容器的核心容器运行时。</li>
<li>Docker公司或者第三方的产品都是围绕Docker引擎开发和集成的。</li>
<li>Docker引擎可以从网上下载也可以基于gGitHub上的源码进行构建。</li>
</ul>
<h3 id="Docker开源项目-Moby"><a href="#Docker开源项目-Moby" class="headerlink" title="Docker开源项目(Moby)"></a>Docker开源项目(<code>Moby</code>)</h3><ul>
<li>开源docker项目包括一系列可以从Docker官网可以下载和安装的工具。比如docker的服务端和客户端。</li>
<li>Moby项目的目标是基于开源的方式，发展称为docker上游，并将Docker拆分为更多的模块化组件。</li>
<li>Moby项目托关于GitHub的Moby代码库，包括子项目和工具列表。</li>
<li>核心的Docker引擎项目位于GitHub的moby/moby。目前引擎中的代码正持续被拆分和模块化。</li>
</ul>
<h3 id="容器生态"><a href="#容器生态" class="headerlink" title="容器生态"></a>容器生态</h3><ul>
<li>docker公司的核心哲学：<strong>含电池，蛋壳拆卸</strong>。</li>
<li>意思是许多Docker内置的组件都可以替换为第三方的组件。</li>
<li>Docker不断地更新内置电池，使得越来越好用，这样就加剧了容器生态下的竞争和合作。</li>
</ul>
<h3 id="开发容器计划"><a href="#开发容器计划" class="headerlink" title="开发容器计划"></a>开发容器计划</h3><ul>
<li>OCI(<code>the open container initiative</code>)是一个旨在对容器基础架构中的基础组件（如镜像格式于容器运行时）进行标准化的管理委员会。</li>
<li>OCI的两项规范：镜像规范和运行时规范。</li>
</ul>
<h2 id="chapter-3：Docker安装"><a href="#chapter-3：Docker安装" class="headerlink" title="chapter 3：Docker安装"></a>chapter 3：Docker安装</h2><ul>
<li>桌面安装</li>
<li>服务器安装</li>
<li>docker引擎升级</li>
<li>docker存储驱动的选择</li>
</ul>
<h3 id="Linux安装docker"><a href="#Linux安装docker" class="headerlink" title="Linux安装docker"></a>Linux安装docker</h3><ul>
<li><p>首先利用脚本来安装Docker：</p>
<ul>
<li><ol>
<li>使用wget从<a target="_blank" rel="noopener" href="https://get.docker.com获取并运行docker脚本,然后采用shell中管道的方式来执行这个脚本./">https://get.docker.com获取并运行Docker脚本，然后采用shell中管道的方式来执行这个脚本。</a></li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget -qO- https://get.docker.com/ |sh ...</span></span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol>
<li>最好使用非root用户来使用Docker。需要添加非root用户到本地的Docker Unix组中。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo usermod -aG docker your-user ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上述的命令将名字为your-user的用户添加到Docker Unix中。通过下列的命令来查看是否成功安装。</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cat</span> /etc/<span class="built_in">group</span> | grep docker ...</span><br><span class="line">       ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果当前用户就是添加到Docker组中的用户，那么需要重新登录，组权限设置才会生效。</p>
</li>
<li><p>使用如下的命令来查看是否成功安装Docker。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker --version</span><br></pre></td></tr></table></figure>

<h3 id="docker-引擎升级"><a href="#docker-引擎升级" class="headerlink" title="docker 引擎升级"></a>docker 引擎升级</h3><ul>
<li><p>升级Docker引擎是一项重要的任务，特别是生产环境。</p>
</li>
<li><p>升级Docker引擎的关键步骤如下：</p>
<ul>
<li>需要重视升级操作的每一个前置条件，包括确保容器配置了正确的重启策略；</li>
<li>在Swarm Mode模式下使用服务时，需要确保正确配置了draining node。</li>
<li>当完成了上述的前置条件的检查之后，可以通过如下的步骤来完成升级操作：</li>
</ul>
<ol>
<li>停止Docker守护程序</li>
<li>移除旧版本的Docker</li>
<li>安装新版本的Docker</li>
<li>配置新版本的Docker为开机自启动</li>
<li>确保容器重启成功。</li>
</ol>
</li>
</ul>
<h4 id="在Ubuntu-16-04上升级Docker-CE"><a href="#在Ubuntu-16-04上升级Docker-CE" class="headerlink" title="在Ubuntu 16.04上升级Docker CE"></a>在Ubuntu 16.04上升级Docker CE</h4><ul>
<li><p>需要使用sudo来执行以下的命令：</p>
<ol>
<li><p>更新APT包列表<code>$ sudo apt-get update</code></p>
</li>
<li><p>卸载当前Docker<code>$ sudo apt-get remove docker docker-engine docker-ce docker.io -y</code></p>
</li>
<li><p>安装新版本的Docker</p>
<ul>
<li><p>有不同的版本的Docker可供选择，并且有多种方式可以安装Docker。可以通过apt或者deb包管理方式进行安装；也可以通过Docker官方的脚本进行安装。<code>$ wget -qO- https://get.docker.com/ | sh</code></p>
</li>
<li><p>上述通过脚本完成安装。</p>
</li>
</ul>
</li>
<li><p>将Docker配置为开机自启动</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">enable</span> docker   <span class="comment"># 设置开机自启动 ...</span></span><br><span class="line">...</span><br><span class="line">$ systemctl is_enable docekr <span class="comment"># 检查开机自启动设置成功与否 enable    # 成功</span></span><br></pre></td></tr></table></figure>

<ol>
<li>检查并确保每一个容器和服务器都已经重启成功</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls    <span class="comment"># 列出所有的容器 Container ID     Image     command     created     status ...                ...      ...           ...       ...</span></span><br><span class="line">$ docker service ls      <span class="comment"># 列出所有的服务器 ID        NAME         MODE       REPLACE　　　　　IAMGE ...       ...          ...        ...            ...</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Docker-存储驱动的选择"><a href="#Docker-存储驱动的选择" class="headerlink" title="Docker 存储驱动的选择"></a>Docker 存储驱动的选择</h3><ul>
<li><p>每个Docker容器都有一个本地的存储空间，用于保存层叠的镜像层以及挂在的容器文件系统。</p>
</li>
<li><p>默认情况下，容器所有的读写操作都发生在其镜像层上或者挂在的文件系统中，所以存储是每个容器的性能和稳定性不可或缺的一个环节。</p>
</li>
<li><p>Docker在Linux底层支持不同的存储驱动的具体实现，每一种实现方式采取不同的方式实现了镜像层和写时复制。尽管底层实现的差异不影响用户与Docker之间的交互，但是影响Docker的性能和稳定性。</p>
</li>
<li><p>在Linux上，Docker可选择的一些存储驱动包括：</p>
<ul>
<li>AUFS</li>
<li>Overlay2</li>
<li>Device Mapper</li>
<li>Btrfs</li>
<li>ZFS</li>
</ul>
</li>
<li><p>存储驱动的选择时节点级别的，也就是说每个主机只能选择一种存储驱动，不能每一个容器来选择不同的存储驱动。</p>
</li>
<li><p>在Linux上，通过修改<code>/etc/docker/daemon.json</code>文件来修改存储驱动引擎配置，修改完成后需要重启才能生效。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;    <span class="string">&quot;storage-driver&quot;</span>: <span class="string">&quot;overlay2&quot;</span> &#125; <span class="comment"># 各配置行之间通过逗号隔开。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果修改了正在运行的Docker主机的存储引擎类型，则现有的镜像和容器在重启之后将不可用，因为每种存储驱动在主机上的存储镜像层的位置不同。修改了存储驱动的类型，Docker就无法找到原有的镜像和容器了。当然切换到原来的存储驱动，之前的镜像和容器就可以继续使用。</p>
</li>
<li><p>为了在切换存储驱动之后还能继续使用之前的镜像和容器，需要将镜像保存为Docker格式，上传到某个镜像仓库，修改本地Docker存储引擎并重启，之后从镜像仓库将镜像拉取到本地，最后重启容器。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker system info &lt;Snip&gt; Storage Driver: overlay2   Backing Filesystem: xfs   Supports d_type: <span class="literal">true</span>   Native Overlay Diff: <span class="literal">true</span> &lt;Snip&gt;</span><br></pre></td></tr></table></figure>

<h2 id="chapter-4-纵观Dockers"><a href="#chapter-4-纵观Dockers" class="headerlink" title="chapter 4 : 纵观Dockers"></a>chapter 4 : 纵观Dockers</h2><ul>
<li>运维视角</li>
<li>开发视角</li>
<li>运维视角包括：镜像下载，运行新的容器，登录新容器，在容器内运行命令，以下销毁容器。</li>
<li>开发视角包括：关注与应用相关的内容。</li>
</ul>
<h3 id="运维视角"><a href="#运维视角" class="headerlink" title="运维视角"></a>运维视角</h3><ul>
<li><p>安装Docker的时候，涉及两个主要组件：</p>
<ul>
<li>Docker客户端</li>
<li>Docker daemon（服务端，引擎）：daemon实现了Docker引擎的API。</li>
</ul>
</li>
<li><p>使用Linux默认安装时，客户端与daemon之间的通信时通过本地IPC／UNIX Socket完成（<code>/var/run/docker.sock</code>)。</p>
</li>
<li><p>可以通过<code>docker version</code>来检测客户端和服务端是否安装成功，并且可以相互通信。</p>
</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker version Client:   Version:...</span><br><span class="line">  API version:...</span><br><span class="line">  Go version:...</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">Server:   Engine:    Version:...</span><br><span class="line">   ...</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>



<h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><ul>
<li><p>将Docker镜像理解为一个包含了OS文件系统和应用的对象较为好理解。</p>
</li>
<li><p>在Docker的世界里，镜像实际上等价于未运行的容器。</p>
</li>
<li><p>使用如下命令查看镜像：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<ul>
<li><p>镜像包含了基础操作系统，以及应用程序所运行的代码和依赖包。</p>
</li>
<li><p>Docker的每一个镜像都有自己的唯一的ID。用户可以通过引用镜像的ID或者名称来使用镜像。显然这里的ID和镜像的名称是唯一对应的。不可能存在重复的ID或者重复的名称。</p>
</li>
</ul>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><ul>
<li><p>当拥有一个拉取到本地的镜像，可以使用<code>docker container run</code>命令从镜像中启动容器。<code>$ docker container run -it ubuntu:latest /bin/bash</code></p>
<ul>
<li><p><code>docker container run</code>告诉<code>docker daemon</code>启动新的容器。<code>-it</code>参数告诉Dockers开启容器的交互模式为读者当前的shell应用连接到容器终端。</p>
</li>
<li><p><code>ubuntu:latest</code>指定基础镜像。</p>
</li>
<li><p>最后的应用程序表明想要在容器中运行什么程序。</p>
</li>
<li><p>按<code>Ctrl+PQ</code>组合键，可以在退出容器的同时保持容器的运行。</p>
</li>
</ul>
</li>
</ul>
<h4 id="连接到运行中的容器"><a href="#连接到运行中的容器" class="headerlink" title="连接到运行中的容器"></a>连接到运行中的容器</h4><ul>
<li>执行<code>docker container exec</code>命令，可以将shell连接到一个运行中的容器终端.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">exec</span> -it vigilant_borg bash <span class="comment"># 其中容器名为-vigilant_borg # 标准格式：docker container exec &lt;options&gt; &lt;container-name or container-id&gt; &lt;conmand/app&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>docker container stop container-name</code>和<code>docker container rm</code>命令来停止并且杀死容器。</li>
<li>通过运行<code>docker container ls</code>命令，并指定<code>-a</code>参数来确定容器已经被成功删除。添加<code>-a</code>参数的作用是让Docekr列出所有的容器，包括被杀死的容器。</li>
</ul>
<h3 id="开发视角"><a href="#开发视角" class="headerlink" title="开发视角"></a>开发视角</h3><ul>
<li>容器即应用。</li>
<li>每一个仓库中都包含一个名为Dockerfile的文件。它是一个纯文本，其中描述了如何将应用构建到Docker镜像当中。</li>
<li>使用<code>docker image build</code>命令，根据Dockerfile中的指令来创建新的镜像。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docekr image -t <span class="built_in">test</span>:latest <span class="comment"># 指定新建的镜像名为test:latest</span></span><br></pre></td></tr></table></figure>

<ul>
<li>从镜像中启动容器，并测试应用。Linux代码如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -d \   --name web1 \   --publish 8080:8080 \   <span class="built_in">test</span>:latest</span><br></pre></td></tr></table></figure>

<ul>
<li>将应用代码构建到Docker镜像中，然后以容器的方式启动该镜像，该过程叫做“应用容器化”。</li>
</ul>
<h2 id="chapter-5-：Docker引擎"><a href="#chapter-5-：Docker引擎" class="headerlink" title="chapter 5 ：Docker引擎"></a>chapter 5 ：Docker引擎</h2><h3 id="Docker-引擎-简介"><a href="#Docker-引擎-简介" class="headerlink" title="Docker 引擎-简介"></a>Docker 引擎-简介</h3><ul>
<li>Docker引擎是用来运行和管理容器的核心软件。</li>
<li>基于OCI相关标准的要求，Docker引擎采用了模块化的设计原则，其组件是可以替换的。</li>
<li>Docker引擎的主要组件包括：(以下共同负责容器的创建和运行)<ul>
<li>Docker(docker client)客户端</li>
<li>Docker(docker daemon)守护进程</li>
<li>containerd</li>
<li>runc</li>
</ul>
</li>
<li>总体的逻辑结构如下：</li>
</ul>
<img src="/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8%E6%80%BB%E6%9E%B6%E6%9E%84%E5%9B%BE.PNG" class>

<h3 id="Docker-引擎-详解"><a href="#Docker-引擎-详解" class="headerlink" title="Docker 引擎-详解"></a>Docker 引擎-详解</h3><ul>
<li>Docker发布时，Docker引擎由两个核心组件构成：<ul>
<li>LXC</li>
<li>Docker daemon</li>
</ul>
</li>
<li>Docker daemon是单一的二进制文件，包含诸如Docker客户端，Docker API,容器运行时，镜像构建等。</li>
<li>LXC提供了对诸如命名空间（namespace) 和控制组(Cgroup)等基础工具的操作能力，他们是基于Linux内核的容器虚拟机化技术。</li>
<li>旧版本的Docker的核心组件的关系：</li>
</ul>
<img src="/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/%E6%97%A7%E7%89%88%E6%9C%ACDocker%E6%9E%B6%E6%9E%84.PNG" class>

<h4 id="摆脱LXC"><a href="#摆脱LXC" class="headerlink" title="摆脱LXC"></a>摆脱LXC</h4><ul>
<li>LXC基于Linux。对于跨平台问题较大。</li>
<li>Docker公司开发了名为<code>Libcontainer</code>的自研工具，用于替代LXC。</li>
<li>Libcontainer的目标是成为与平台无关的工具。可基于不同的内核为Docker上层提供必要的容器交互功能。</li>
<li>在Docker0.9版本中，Libcontainer取代LXC称为默认的执行驱动。</li>
</ul>
<h4 id="摒弃大而全的Docker-daemon"><a href="#摒弃大而全的Docker-daemon" class="headerlink" title="摒弃大而全的Docker daemon"></a>摒弃大而全的Docker daemon</h4><ul>
<li>Docker daemon的整体性带来了越来越多的问题。<ul>
<li>难于变更</li>
<li>运行越来越慢</li>
<li>并非生态所期望</li>
</ul>
</li>
<li>Docker公司也继承UNIX中的哲学：小而专的工具可以组装称为大型工具。</li>
<li>目前的Docker引擎的架构图如下：</li>
</ul>
<img src="/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/Docker%E5%BC%95%E6%93%8E%E7%9A%84%E6%9E%B6%E6%9E%84.PNG" class>

<h4 id="runc"><a href="#runc" class="headerlink" title="runc"></a>runc</h4><ul>
<li>runc是OCI容器运行时规范的参考实现。</li>
<li>Docker公司参与了规范的制定和runc的开发。</li>
<li>runc实质上是一个轻量级的，针对Libcontainer进行了包装的命令行交互工具。</li>
<li>runc的唯一作用就是：创建容器。</li>
<li>runc实质上就是一个独立的容器运行时工具，直接下载它或者基于源码编译的二进制文件即可拥有全功能的runc。</li>
</ul>
<h4 id="containerd"><a href="#containerd" class="headerlink" title="containerd"></a>containerd</h4><ul>
<li>docker daemon的功能拆解之后，所有的容器执行逻辑被重构到一个新的名为containerd的工具中。主要任务在于：管理容器的声明周期。(start | stop | pause | rm…)</li>
<li>containerd在Linux中以daemon的方式运行，从1.11版本之后，Docker就开始在Linux上使用他。Docker银枪技术栈中，containerd位于daemon和runc所在的OCI层之间。</li>
<li>Kubernetes也可以通过cri-containers使用containerd。</li>
</ul>
<h4 id="启动一个新的容器"><a href="#启动一个新的容器" class="headerlink" title="启动一个新的容器"></a>启动一个新的容器</h4><ul>
<li>首先利用<code>docker container run</code>来启动一个新的容器。</li>
<li>当Docker客户端接收到相应的启动命令，将其转换为合适的API 格式，转发到合适的API端点。</li>
<li>API实在daemon中实现的。</li>
<li>daemon使用一种CRUD风格的API，通过gRPC与containerd进行通信。</li>
<li>而真正创建容器的功能是runc做的，containerd及那个Dockers进项转换为OCI bundle，并让runc基于此创建新的容器。</li>
<li>runc与操作系统内核接口进行通信，基于所有必要的工具来创建容器，容器进程作为runc的子进程启动，启动完毕后，runc将会退出。</li>
</ul>
<h4 id="该模型的显著优势"><a href="#该模型的显著优势" class="headerlink" title="该模型的显著优势"></a>该模型的显著优势</h4><ul>
<li>将所有的用于启动、管理容器的逻辑和代码从daemon中移除，意味着容器运行时与Docker daemon是解耦的。称之为“无守护进程的容器”，因此，对Docker daemon的维护和升级不会影响运行中的容器。</li>
</ul>
<h4 id="shim"><a href="#shim" class="headerlink" title="shim"></a>shim</h4><ul>
<li>shim是实现无daemon的容器不可或缺的工具。</li>
<li>containerd指导runc来创建新容器，每个容器创建都会fork一个新的runc实例。不过，一旦容器创建完毕，对应的runc进程就会退出。</li>
<li>一旦容器进程的父进程runc退出，相关联的containerd-shim进程就会成为容器的父进程，作为容器的父进程，shim的部分职责如下：<ul>
<li>保持所有的STDIN和STDOUT流是开启状态，从而当daemon重启时，容器不会因为管道的关闭而终止。</li>
<li>将容器的退出状态反馈给daemon。</li>
</ul>
</li>
<li>被抽离的daemon的主要功能就是镜像管理，镜像构建，REST API，身份验证，安全，核心网络以及编排。</li>
</ul>
<h2 id="chapter-6-：-Docker-镜像"><a href="#chapter-6-：-Docker-镜像" class="headerlink" title="chapter 6 ：  Docker 镜像"></a>chapter 6 ：  Docker 镜像</h2><ul>
<li>镜像的简介</li>
<li>镜像的详解</li>
<li>镜像命令</li>
</ul>
<h3 id="Docker镜像——简介"><a href="#Docker镜像——简介" class="headerlink" title="Docker镜像——简介"></a>Docker镜像——简介</h3><ul>
<li>首先需要从仓库中拉取镜像到本地，然后可以使用该镜像来启动一个或者多个容器。</li>
<li>镜像由多个层组成，每层叠加之后，从外部看起来就像一个独立的对象。</li>
<li>镜像内部是一个精简的操作系统，同时还包含应用所必须的文件和依赖包。</li>
</ul>
<h3 id="Docker镜像——详解"><a href="#Docker镜像——详解" class="headerlink" title="Docker镜像——详解"></a>Docker镜像——详解</h3><ul>
<li>根据镜像与容器的关系，可以理解为：<ul>
<li>镜像理解为构建时结构</li>
<li>容器理解为运行时结构</li>
</ul>
</li>
</ul>
<h4 id="镜像和容器"><a href="#镜像和容器" class="headerlink" title="镜像和容器"></a>镜像和容器</h4><ul>
<li>一旦容器从镜像启动后，二者就变成了相互依赖的关系，并且在镜像启动的容器全部停止之前，镜像时无法被删除的。</li>
</ul>
<h4 id="镜像通常比较小"><a href="#镜像通常比较小" class="headerlink" title="镜像通常比较小"></a>镜像通常比较小</h4><ul>
<li>容器的目的时运行应用或者服务，必须包含应用所需要的操作系统和应用文件。</li>
<li>镜像中不包含内核——–容器都是共享所在Docker主机的内核。</li>
</ul>
<h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><ul>
<li>Docker主机安装后，本地并没有镜像。</li>
<li>Linux Docker主机的镜像仓库通常位于<code>/var/lib/docker/&lt;storage-driver&gt;</code>.可以通过检查该目录中是否存在镜像。</li>
<li>通过<code>sudo docker image pull ubuntu:latest</code>命令拉取镜像到本地主机。</li>
</ul>
<h4 id="镜像仓库服务"><a href="#镜像仓库服务" class="headerlink" title="镜像仓库服务"></a>镜像仓库服务</h4><ul>
<li>Docker镜像存储在镜像仓库服务当中。Docker客户端的镜像仓库服务时可以配置的，默认使用Docker Hub。</li>
<li>镜像仓库服务包含多个镜像仓库，同样，一个镜像仓库可以存在多个镜像。</li>
<li>仓库分为官方仓库和非官方仓库，两者的差别在于镜像的可靠性。</li>
<li>如果没有在仓库名称中制定具体的镜像标签，Docker会认为假设用户希望拉取标签为latest的镜像。</li>
</ul>
<h4 id="镜像和分层"><a href="#镜像和分层" class="headerlink" title="镜像和分层"></a>镜像和分层</h4><ul>
<li><p>Docker镜像由一些松耦合的只读镜像层组成。</p>
</li>
<li><p>Docker负责堆叠这些镜像层，并且将他们表示为单个统一的对象。</p>
</li>
<li><p>通过<code>docker image inspect</code>命令来查看镜像的层次结构。以ubuntu:latest为例：<code>$ docker image inspect ubuntu:latest</code></p>
</li>
<li><p>所有的Docker镜像都起始于一个基础镜像层，当进行修改或者增加新的内容时，就会在当前的镜像层之上创建新的镜像层。</p>
</li>
<li><p>Docker通过存储引擎的方式来实现镜像层堆栈，并且保证多个镜像层对外展示为统一的文件系统。</p>
</li>
<li><p>每种存储引擎都基于Linux中对应的文件系统或者块设备技术，并且每种存储引擎都具有独有的性能特点。</p>
</li>
</ul>
<h4 id="共享镜像层"><a href="#共享镜像层" class="headerlink" title="共享镜像层"></a>共享镜像层</h4><ul>
<li>多个镜像之间可以并且确实会共享镜像层。这样有效提升节省存储空间的性能。</li>
<li>也就是说镜像层之间的层次关系是一种逻辑关系，通过逻辑的分层将其组成一个镜像层整体。</li>
</ul>
<h4 id="多层架构的镜像"><a href="#多层架构的镜像" class="headerlink" title="多层架构的镜像"></a>多层架构的镜像</h4><ul>
<li>Docker规范支持多架构镜像。意味着镜像仓库标签下的镜像同时可以支持Linux、Windows、arm等多种架构。</li>
</ul>
<h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><ul>
<li><p>利用<code>docker image rm</code>命令实现镜像的删除，删除操作会在当前的主机上删除该镜像以及相关的镜像层。</p>
</li>
<li><p>如果某个镜像层被多个镜像共享，那只有当全部依赖该镜像层的镜像都被删除之后，该镜像才会被删除。</p>
</li>
<li><p>一键删除全部镜像的命令：<code>$ docker image rm $(docker image ls -q) -f</code></p>
</li>
</ul>
<h2 id="chapter-7-Docker-容器"><a href="#chapter-7-Docker-容器" class="headerlink" title="chapter 7: Docker 容器"></a>chapter 7: Docker 容器</h2><ul>
<li>简介</li>
<li>详解</li>
<li>命令</li>
</ul>
<h3 id="Docker容器——简介"><a href="#Docker容器——简介" class="headerlink" title="Docker容器——简介"></a>Docker容器——简介</h3><ul>
<li>容器时镜像的运行时实例。</li>
<li>用户可以同时从单个镜像中启动多个容器。</li>
<li>容器会共享其所在主机的操作系统/内核。</li>
<li>镜像华人容器的关系如下图：</li>
</ul>
<img src="/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE.PNG" class>
<ul>
<li>启动容器简便的方式是使用<code>docker container run</code>命令。该命令可以携带很多参数。<ul>
<li>基本的命令格式：<code>docker container run &lt;image&gt; &lt;app&gt;</code>.</li>
<li>参数说明：<ul>
<li><code>-it</code>：指定运行的应用程序。</li>
</ul>
</li>
</ul>
</li>
<li>容器的手动停止：<code>docker container stop</code>命令实现。</li>
<li>容器的重新启动：<code>docker container restart</code>命令实现。</li>
<li>容器的手动删除：<code>docker container rm</code>命令实现。</li>
</ul>
<h3 id="Docker容器——详解"><a href="#Docker容器——详解" class="headerlink" title="Docker容器——详解"></a>Docker容器——详解</h3><ul>
<li><p><strong>虚拟机模型</strong>：</p>
<ul>
<li>首先开启物理机并启动Hypervisor引导程序。</li>
<li>一旦Hypervisor启动，就会占有机器上所有的物理资源。</li>
<li>Hypervisor将上述获取的资源划分为虚拟资源，并且抽象成和物理资源一样的虚拟资源。</li>
<li>Hypervisor将抽象的虚拟资源打包进一个虚拟机的软件结构中，提供用户使用。</li>
</ul>
</li>
<li><p><strong>虚拟机架构</strong>：</p>
</li>
</ul>
<img src="/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/%E8%99%9A%E6%8B%9F%E6%9C%BA-4%E4%B8%AA%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F.PNG" class>
<ul>
<li><strong>容器模型</strong>：<ul>
<li>服务器启动以后，所选择的操作系统会启动。</li>
<li>与虚拟机相同的是，OS会占用全部资源。</li>
<li>在OS层上，需要安装容器引擎，如Docker。</li>
<li>容器引擎可以获取系统资源，包括进程树，文件系统以及网络栈。</li>
<li>容器引擎将上述的资源分割为安全的相互隔离的资源结构，称之为容器。</li>
<li>每个容器看起来像真实的操作系统，内部可以运行应用。</li>
</ul>
</li>
<li><strong>容器架构</strong>：</li>
</ul>
<img src="/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/%E5%88%92%E5%88%864%E4%B8%AA%E5%AE%B9%E5%99%A8.PNG" class>
<ul>
<li><strong>容器与虚拟机的对比</strong>：<ul>
<li>Hypervisor是硬件虚拟化（<code>Hardware Virtualization</code>):将硬件资源划分为虚拟资源。</li>
<li>容器是操作系统虚拟化（<code>OS virtualization</code>):将系统资源划分为虚拟资源。</li>
<li>虚拟机占用的额外资源较多。每个操作系统都会存在额外资源。</li>
<li>容器启动较快，无需初始化硬件资源。</li>
</ul>
</li>
<li><strong>容器进程</strong><ul>
<li>通过命令<code>ps -elf</code>来查看容器中运行的进程。</li>
<li>容器如果不运行 任何进程的话，将无法存在，所以通过exit退出shell也就退出了容器。</li>
<li>而通过Ctrl+PQ组合键则会退出容器但并不终止容器运行。</li>
<li>通过命令<code>docker container exec -it container-ID bash</code>重新连接到Docker。</li>
</ul>
</li>
<li><strong>容器生命周期</strong><ul>
<li>首先通过<code>docker container run</code>命令创建一个容器。</li>
<li>其次通过<code>docker container stop</code>命令停止一个容器。（并不会删除容器中的文件等信息，说明了容器具有持久化的特点）</li>
<li>然后通过<code>docker container start</code>命令重启一个容器。</li>
<li>最后通过<code>docker container rm</code>命令删除一个容器（两步走：先停止容器运行，再删除容器，优雅的方式，通过Linux/POSIX信号来实现）。</li>
</ul>
</li>
<li><strong>容器的持久化</strong><ul>
<li>停止容器的运行并不会损毁容器或者容器中的数据，这一点体现了容器的持久化的特性。</li>
<li><strong>卷</strong>是容器中存储持久化数据的首选方式。</li>
<li>存储在卷中的数据并不会随着容器的删除被删除，依然能通过相应的方式找到其数据。</li>
</ul>
</li>
<li><strong>容器的重启策略实现自我修复</strong><ul>
<li><code>always</code>:只有除了容器被stop命令明确停止，否则该策略会一直尝试重启处于停止状态的容器。</li>
<li><code>unless-stopped</code>:被指定为该项目的容器不会在Docker daemon重启的时候重启。</li>
<li><code>on-failed</code>:在退出容器并且返回值不是0的时候，重启容器。就算容器处于stopped状态，在Docker daemon重启的时候，容器也会被重启。</li>
</ul>
</li>
</ul>
<h2 id="chapter-8：-应用的容器化"><a href="#chapter-8：-应用的容器化" class="headerlink" title="chapter 8： 应用的容器化"></a>chapter 8： 应用的容器化</h2><ul>
<li><p>Docker的核心思想就是如何将应用整合到容器中，并且能在容器中实际运行。这个过程就叫做应用的容器化。</p>
</li>
<li><p>简介</p>
</li>
<li><p>详解</p>
</li>
<li><p>命令</p>
</li>
</ul>
<h3 id="应用的容器化——简介"><a href="#应用的容器化——简介" class="headerlink" title="应用的容器化——简介"></a>应用的容器化——简介</h3><ul>
<li>容器是为应用而生，容器能够简化应用的构建、部署和运行过程。</li>
<li>完整的应用容器化过程分为以下几个步骤：<ol>
<li>编写应用代码</li>
<li>创建一个Dockerfile，其中包括当前应用的描述、依赖以及该如何运行这个应用。</li>
<li>对该Dockerfile执行docker image build命令。</li>
<li>等待Docker将应用程序构建到Docker镜像中。</li>
</ol>
</li>
<li>一旦应用容器化完成，就能以镜像的形式交付以容器的方式运行了。</li>
</ul>
<img src="/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/%E5%AE%B9%E5%99%A8%E5%8C%96%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B.PNG" class>

<h3 id="应用的容器化——详解"><a href="#应用的容器化——详解" class="headerlink" title="应用的容器化——详解"></a>应用的容器化——详解</h3><ul>
<li>单体应用容器化</li>
<li>生产环境中的多阶段构建</li>
<li>最佳实践</li>
</ul>
<h4 id="单体应用容器化"><a href="#单体应用容器化" class="headerlink" title="单体应用容器化"></a>单体应用容器化</h4><ul>
<li>以单节点Node.js Web为例讲述单体应用的容器化过程。</li>
<li>获取应用代码：<ul>
<li>从Github中获取。</li>
</ul>
</li>
<li>分析Dockerfile<ul>
<li>Dockerfile文件包含了对应当前应用的描述，并且能够指导Docker完成镜像的构建。</li>
<li>在Docker中，包含应用文件的目录通常被称之为构建上下文，通常将Dockerfile放到构建上下文的根目录下。</li>
<li>Dockerfile的文件名固定。</li>
<li>Dockerfile的用途：<ul>
<li>对当前应用进行描述</li>
<li>指导Docker完成应用的容器化。</li>
</ul>
</li>
</ul>
</li>
<li>构建应用镜像</li>
<li>运行该应用</li>
<li>测试应用</li>
<li>容器应用细节</li>
<li>生产环境中的多阶段构建</li>
<li>最佳实践：</li>
</ul>
<h4 id="生产环境中的多阶段构建"><a href="#生产环境中的多阶段构建" class="headerlink" title="生产环境中的多阶段构建"></a>生产环境中的多阶段构建</h4><ul>
<li>对于docker镜像来说，多大的体积并不好。越大越慢，更难使用，更加脆弱。</li>
<li>不同的dockerfile写法会对镜像的大小产生显著的影响。尽量减少镜像层的方式可以减少镜像体积，将多个run指令放在一起。</li>
<li>另一个方式就是多阶段构建：<ul>
<li>多阶段构建方式使用一个dockerfile，其中包含多个FROM指令。每一个from指令都是一个新的构建阶段，并且可以方便地复制之前阶段的构建。</li>
<li>复制前阶段的命令就是：<code>COPY --from</code>。</li>
</ul>
</li>
</ul>
<h3 id="应用的容器化——-命令"><a href="#应用的容器化——-命令" class="headerlink" title="应用的容器化——-命令"></a>应用的容器化——-命令</h3><ul>
<li><code>docker image build</code>命令会读取Dockerfile，并将应用程序容器化。使用-t参数为镜像打上标签，使用-f参数指定Dockerfile的路径和名称，使用-f参数可以指定位于任意位置路径下的任意名称的Dockerfile。构建上下文是指文件存放的位置，可能是本地的docker主机的一个目录或者一个远程的Git仓库。</li>
<li>Dockerfile的From指令用于指定要构建的镜像的基础镜像。它通常是Dockerfile的第一条指令。</li>
<li>Dockerfile中的run指令用于在镜像中执行命令，这会创建新的镜像层。每一个run指令闯将iyge镜像层。</li>
<li>Dockerfile中的Copy指令用于将文件作为新的层添加镜像中。通常使用copy指令将应用代码赋值到镜像中。</li>
<li>Dockerfile中的entrypoint指令用于指定镜像以容器方式启动后默认运行的程序。</li>
<li>Dockerfile中还有其他的命令。</li>
</ul>
<h2 id="chapter-10-Docker-Swarm"><a href="#chapter-10-Docker-Swarm" class="headerlink" title="chapter 10 Docker Swarm"></a>chapter 10 Docker Swarm</h2><ul>
<li>swarm 的核心组件<ul>
<li>安全集群</li>
<li>编排引擎</li>
</ul>
</li>
<li>three part<ul>
<li>简介</li>
<li>详解</li>
<li>命令</li>
</ul>
</li>
</ul>
<h3 id="Docker-Swarm—简介"><a href="#Docker-Swarm—简介" class="headerlink" title="Docker Swarm—简介"></a>Docker Swarm—简介</h3><ul>
<li>Docker Swarm包含两个方面：<ul>
<li>企业级的Docker安全集群</li>
<li>微服务应用编排引擎</li>
</ul>
</li>
<li><strong>集群</strong>：<ul>
<li>swarm将一个或者多个docker节点组织起来，使得用户能够以集群方式管理它们。swarm默认内置有加密的分布式集群存储，加密网络，公用TLS，安全集群接入令牌以及一套简化数字证书管理的PKI。用户可以自如删除或者添加节点。</li>
</ul>
</li>
<li><strong>编排</strong>：<ul>
<li>swarm提供一套丰富的API使得部署和管理复杂的微服务应用变得简单，通过将应用定义在声明式的配置文件中，就可以使用原生的Docker命令完成部署。还可以执行滚动升级，回滚以及扩容操作，同样基于简单的命令即可完成。</li>
</ul>
</li>
</ul>
<h3 id="Docker-Swarm-—-详解"><a href="#Docker-Swarm-—-详解" class="headerlink" title="Docker Swarm —-详解"></a>Docker Swarm —-详解</h3><ul>
<li>从集群的角度说，一个swarm由一个或者多个docker节点组成，节点可以是物理服务器，虚拟机，树莓派或者云实例。前提就是可以通过连接到每个节点。</li>
<li>节点会被配置为管理节点(<code>manager</code>)或者工作节点(<code>worker</code>)。管理节点负责集群控制面，进行监控集群状态，分发任务到工作节点。工作节点接收来自管理节点的任务并执行。</li>
<li>swarm的配置和状态信息保存在一套位于所有管理节点的分布式etcd数据库中。该数据库运行于内存中，并保持数据的最新状态。</li>
<li>swarm的架构如下：</li>
</ul>
<img src="/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/swarm%E6%9E%B6%E6%9E%84.jpg" class>

<h2 id="chapter-11-Docker-网络"><a href="#chapter-11-Docker-网络" class="headerlink" title="chapter 11 Docker 网络"></a>chapter 11 Docker 网络</h2><ul>
<li>简介</li>
<li>详解</li>
<li>命令</li>
</ul>
<h3 id="Docker网络—简介"><a href="#Docker网络—简介" class="headerlink" title="Docker网络—简介"></a>Docker网络—简介</h3><ul>
<li>容器之间的应用需要通过网路进行交互。</li>
<li>容器之间、容器与外部网络、VLAN之间的连接均需要提供相应的解决方案。</li>
<li>Docker的网路架构源于容器网络模型的解决方案。</li>
<li>docker的网络架构实现方式有libnetwork/</li>
<li>docker封装了一系列本地驱动、覆盖了大部常见的网络需求，包括单机桥接网路、多机覆盖网络并且支持接入现有的VLAN。</li>
<li>总结：libnetwork提供了本地服务发现和基础的容器均衡负载解决方案。</li>
</ul>
<h3 id="Docker-网络—详解"><a href="#Docker-网络—详解" class="headerlink" title="Docker 网络—详解"></a>Docker 网络—详解</h3><ul>
<li>基础理论</li>
<li>单机桥接网络</li>
<li>多级覆盖网络</li>
<li>服务发现</li>
<li>Ingress网络</li>
</ul>
<h4 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h4><ul>
<li>docker’的网络架构主要分为三层:CNM libnetwork和驱动</li>
<li>其中CNM是设计标准,规定了docker网络架构的基础组成要素.</li>
<li>libnetwork是CNM的具体实现,并且被docker采用,libnetwork通过go语言实现.</li>
<li>驱动通过实现具体的网络拓扑的方式来扩展该模型的能力.</li>
<li><strong>CNM</strong><ul>
<li>CNM定义了3个基本要素:沙盒 终端和网络.</li>
<li>沙盒是独立的网络栈,其中包括以太网接口,端口,路由表和DNS配置.</li>
<li>终端是虚拟网络接口,终端主要职责是负责创建连接.终端负责将沙盒连接到网络.</li>
<li>网络是802.1d网桥(交换机)的软件实现.</li>
<li>沙盒被放置在容器的内部,为容器提供网络连接.</li>
<li>三层路由的支持主要是为了容器之间的通信.</li>
<li>终端接入网络的方式是一一映射.连接不同的网络就需要不同的终端.</li>
<li>沙盒从逻辑上提供容器之间的网络在操作系统层面的独立性.</li>
</ul>
</li>
<li><strong>Libnetwork</strong><ul>
<li>docker模块化之后,libnetwork是其网络架构的主要实现方式.</li>
</ul>
</li>
<li><strong>驱动</strong><ul>
<li>libnetwork实现了控制层和管理层的功能,驱动则是实现数据层.</li>
<li>三者的关系如下图:</li>
</ul>
</li>
</ul>
<img src="/blog/2021/03/23/Docker%E5%9F%BA%E7%A1%80/%E4%B8%89%E5%B1%82%E5%85%B3%E7%B3%BB.PNG" class>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/Docker/" rel="tag"># Docker</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2021/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" rel="prev" title="数据库基本概念">
      <i class="fa fa-chevron-left"></i> 数据库基本概念
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2021/03/27/java8%E5%AE%9E%E6%88%98/" rel="next" title="java8实战">
      java8实战 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-1%EF%BC%9Adocker-%E6%A6%82%E8%A7%88"><span class="nav-number">1.</span> <span class="nav-text">Part 1：docker 概览</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-1%EF%BC%9A%E5%AE%B9%E5%99%A8%E5%8F%91%E5%B1%95%E4%B9%8B%E8%B7%AF"><span class="nav-number">1.1.</span> <span class="nav-text">chapter 1：容器发展之路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%90%BD%E5%90%8E%E7%9A%84%E6%97%B6%E4%BB%A3"><span class="nav-number">1.1.1.</span> <span class="nav-text">落后的时代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="nav-number">1.1.2.</span> <span class="nav-text">虚拟机的出现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E5%87%BA%E7%8E%B0"><span class="nav-number">1.1.3.</span> <span class="nav-text">容器的出现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E5%AE%B9%E5%99%A8"><span class="nav-number">1.1.4.</span> <span class="nav-text">Linux容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows%E5%AE%B9%E5%99%A8"><span class="nav-number">1.1.5.</span> <span class="nav-text">Windows容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kubernetes"><span class="nav-number">1.1.6.</span> <span class="nav-text">Kubernetes</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-2%EF%BC%9A%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80"><span class="nav-number">1.2.</span> <span class="nav-text">chapter 2：容器基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker%E7%AE%80%E4%BB%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">Docker简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker%E5%85%AC%E5%8F%B8"><span class="nav-number">1.2.2.</span> <span class="nav-text">Docker公司</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B8%8E%E7%BC%96%E6%8E%92%E5%BC%95%E6%93%8E"><span class="nav-number">1.2.3.</span> <span class="nav-text">Docker运行时与编排引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-Moby"><span class="nav-number">1.2.4.</span> <span class="nav-text">Docker开源项目(Moby)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%94%9F%E6%80%81"><span class="nav-number">1.2.5.</span> <span class="nav-text">容器生态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E5%AE%B9%E5%99%A8%E8%AE%A1%E5%88%92"><span class="nav-number">1.2.6.</span> <span class="nav-text">开发容器计划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-3%EF%BC%9ADocker%E5%AE%89%E8%A3%85"><span class="nav-number">1.3.</span> <span class="nav-text">chapter 3：Docker安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E5%AE%89%E8%A3%85docker"><span class="nav-number">1.3.1.</span> <span class="nav-text">Linux安装docker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker-%E5%BC%95%E6%93%8E%E5%8D%87%E7%BA%A7"><span class="nav-number">1.3.2.</span> <span class="nav-text">docker 引擎升级</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8Ubuntu-16-04%E4%B8%8A%E5%8D%87%E7%BA%A7Docker-CE"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">在Ubuntu 16.04上升级Docker CE</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">1.3.3.</span> <span class="nav-text">Docker 存储驱动的选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-4-%E7%BA%B5%E8%A7%82Dockers"><span class="nav-number">1.4.</span> <span class="nav-text">chapter 4 : 纵观Dockers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%BB%B4%E8%A7%86%E8%A7%92"><span class="nav-number">1.4.1.</span> <span class="nav-text">运维视角</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%95%9C%E5%83%8F"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">连接到运行中的容器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E8%A7%86%E8%A7%92"><span class="nav-number">1.4.2.</span> <span class="nav-text">开发视角</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-5-%EF%BC%9ADocker%E5%BC%95%E6%93%8E"><span class="nav-number">1.5.</span> <span class="nav-text">chapter 5 ：Docker引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-%E5%BC%95%E6%93%8E-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.5.1.</span> <span class="nav-text">Docker 引擎-简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-%E5%BC%95%E6%93%8E-%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.5.2.</span> <span class="nav-text">Docker 引擎-详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%91%86%E8%84%B1LXC"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">摆脱LXC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%91%92%E5%BC%83%E5%A4%A7%E8%80%8C%E5%85%A8%E7%9A%84Docker-daemon"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">摒弃大而全的Docker daemon</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#runc"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">runc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#containerd"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">containerd</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">1.5.2.5.</span> <span class="nav-text">启动一个新的容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%A5%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%98%BE%E8%91%97%E4%BC%98%E5%8A%BF"><span class="nav-number">1.5.2.6.</span> <span class="nav-text">该模型的显著优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shim"><span class="nav-number">1.5.2.7.</span> <span class="nav-text">shim</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-6-%EF%BC%9A-Docker-%E9%95%9C%E5%83%8F"><span class="nav-number">1.6.</span> <span class="nav-text">chapter 6 ：  Docker 镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker%E9%95%9C%E5%83%8F%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B"><span class="nav-number">1.6.1.</span> <span class="nav-text">Docker镜像——简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker%E9%95%9C%E5%83%8F%E2%80%94%E2%80%94%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.6.2.</span> <span class="nav-text">Docker镜像——详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E5%92%8C%E5%AE%B9%E5%99%A8"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">镜像和容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E9%80%9A%E5%B8%B8%E6%AF%94%E8%BE%83%E5%B0%8F"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">镜像通常比较小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%89%E5%8F%96%E9%95%9C%E5%83%8F"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">拉取镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">镜像仓库服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%95%9C%E5%83%8F%E5%92%8C%E5%88%86%E5%B1%82"><span class="nav-number">1.6.2.5.</span> <span class="nav-text">镜像和分层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%95%9C%E5%83%8F%E5%B1%82"><span class="nav-number">1.6.2.6.</span> <span class="nav-text">共享镜像层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E5%B1%82%E6%9E%B6%E6%9E%84%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-number">1.6.2.7.</span> <span class="nav-text">多层架构的镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><span class="nav-number">1.6.2.8.</span> <span class="nav-text">删除镜像</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-7-Docker-%E5%AE%B9%E5%99%A8"><span class="nav-number">1.7.</span> <span class="nav-text">chapter 7: Docker 容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B"><span class="nav-number">1.7.1.</span> <span class="nav-text">Docker容器——简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker%E5%AE%B9%E5%99%A8%E2%80%94%E2%80%94%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.7.2.</span> <span class="nav-text">Docker容器——详解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-8%EF%BC%9A-%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8C%96"><span class="nav-number">1.8.</span> <span class="nav-text">chapter 8： 应用的容器化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8C%96%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B"><span class="nav-number">1.8.1.</span> <span class="nav-text">应用的容器化——简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8C%96%E2%80%94%E2%80%94%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.8.2.</span> <span class="nav-text">应用的容器化——详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E5%AE%B9%E5%99%A8%E5%8C%96"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">单体应用容器化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">生产环境中的多阶段构建</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E5%8C%96%E2%80%94%E2%80%94-%E5%91%BD%E4%BB%A4"><span class="nav-number">1.8.3.</span> <span class="nav-text">应用的容器化——-命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-10-Docker-Swarm"><span class="nav-number">1.9.</span> <span class="nav-text">chapter 10 Docker Swarm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-Swarm%E2%80%94%E7%AE%80%E4%BB%8B"><span class="nav-number">1.9.1.</span> <span class="nav-text">Docker Swarm—简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-Swarm-%E2%80%94-%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.9.2.</span> <span class="nav-text">Docker Swarm —-详解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chapter-11-Docker-%E7%BD%91%E7%BB%9C"><span class="nav-number">1.10.</span> <span class="nav-text">chapter 11 Docker 网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker%E7%BD%91%E7%BB%9C%E2%80%94%E7%AE%80%E4%BB%8B"><span class="nav-number">1.10.1.</span> <span class="nav-text">Docker网络—简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-%E7%BD%91%E7%BB%9C%E2%80%94%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.10.2.</span> <span class="nav-text">Docker 网络—详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">理论基础</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="RockCohen"
      src="/blog/images/hugo.png">
  <p class="site-author-name" itemprop="name">RockCohen</p>
  <div class="site-description" itemprop="description">a programmer</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/rockcohen" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;rockcohen" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xluo0616@gmail.com" title="E-Mail → mailto:xluo0616@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RockCohen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  















  

  

</body>
</html>
