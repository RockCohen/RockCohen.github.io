<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"rockcohen.gitee.io","root":"/blog/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="英特纳雄耐尔一定要实现">
<meta property="og:type" content="article">
<meta property="og:title" content="Modern OS">
<meta property="og:url" content="https://rockcohen.gitee.io/blog/2021/05/19/OS/index.html">
<meta property="og:site_name" content="Rock Cohen">
<meta property="og:description" content="英特纳雄耐尔一定要实现">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/05/19/OS/cohen.jpg">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/05/19/OS/MMU%E5%8A%9F%E8%83%BD%E4%B8%8E%E4%BD%8D%E7%BD%AE.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/05/19/OS/%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/05/19/OS/TLB%E5%88%86%E9%A1%B5%E5%8A%A0%E9%80%9F%E8%A1%A8.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/05/19/OS/%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/05/19/OS/%E5%B7%A5%E4%BD%9C%E9%9B%86%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/05/19/OS/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/05/19/OS/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/05/19/OS/%E7%AC%AC%E4%B8%80%E7%B1%BB%E4%B8%8E%E7%AC%AC%E4%BA%8C%E7%B1%BB%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F.PNG">
<meta property="og:image" content="https://rockcohen.gitee.io/blog/2021/05/19/OS/%E8%99%9A%E6%8B%9F%E5%86%85%E6%A0%B8%E6%80%81%E6%9E%B6%E6%9E%84%E5%9B%BE.PNG">
<meta property="article:published_time" content="2021-05-19T06:21:59.000Z">
<meta property="article:modified_time" content="2021-05-19T13:43:26.924Z">
<meta property="article:author" content="RockCohen">
<meta property="article:tag" content="OS">
<meta property="article:tag" content="Modern OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rockcohen.gitee.io/blog/2021/05/19/OS/cohen.jpg">

<link rel="canonical" href="https://rockcohen.gitee.io/blog/2021/05/19/OS/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Modern OS | Rock Cohen</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Rock Cohen</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Cohen</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rockcohen.gitee.io/blog/2021/05/19/OS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/hugo.png">
      <meta itemprop="name" content="RockCohen">
      <meta itemprop="description" content="a programmer">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock Cohen">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Modern OS
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-19 14:21:59 / 修改时间：21:43:26" itemprop="dateCreated datePublished" datetime="2021-05-19T14:21:59+08:00">2021-05-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/OS/" itemprop="url" rel="index"><span itemprop="name">OS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <img src="/blog/2021/05/19/OS/cohen.jpg" class>

<h1 id="英特纳雄耐尔一定要实现"><a href="#英特纳雄耐尔一定要实现" class="headerlink" title="英特纳雄耐尔一定要实现"></a>英特纳雄耐尔一定要实现</h1><span id="more"></span>

<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>多道程序设计引来问题：多个进程相互竞争CPU资源。</p>
<p>资源竞争的解决方案：调度程序或者叫做调度算法</p>
<h3 id="调度简介"><a href="#调度简介" class="headerlink" title="调度简介"></a>调度简介</h3><p>进程调度需要考虑进程响应时间给用户带来的影响。进程调度还要考虑系统资源的有限性，正是因为进程与系统资源的不匹配造成调度算法的出现。进程调度需要考虑CPU的利用率，原因在于进程切换需要消耗一部分资源，进程切换过程：</p>
<ul>
<li>首先从用户态转换为内核态；</li>
<li>保存当前进程的状态；</li>
<li>运行调度程序选取新的进程</li>
<li>新的进程装载MMU</li>
<li>新的进程开始运行</li>
</ul>
<p>引入问题：</p>
<ul>
<li>进程切换使得整个内存高速缓存失效，强迫缓存从缓存中动态重新装入两次(进入内核一次，离开内核一次)。</li>
<li>进程切换次数过多导致占用大部分的CPU时间。</li>
</ul>
<h4 id="进程行为"><a href="#进程行为" class="headerlink" title="进程行为"></a>进程行为</h4><p>进程的特点：<strong>I/O请求</strong>与<strong>计算</strong>相互交替。根据I/O请求与计算占比的不同，分为<strong>I/O密集型进程</strong>和<strong>计算密集型进程</strong>。CPU越来越快，而磁盘的进步速度相对较慢，所以更加专注I/O请求带来的CPU损耗，而调度的目的使得磁盘时刻在忙碌，这样提高CPU的利用率。同样CPU与磁盘的差距使得更加专注于I/O请求密集型进程的调度。</p>
<h4 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h4><ol>
<li>当创建一个新的进程时，需要决定运行父进程还是子进程，父进程和子进程都处于就绪状态，调度程序可以合法的选择其中一个首先运行。</li>
<li>进程退出时，需要做出调度决策，不能让CPU闲着。</li>
<li>当一个进程阻塞在I/O和信号量上或者其他原因阻塞时，需要做出调度策略。</li>
<li>当I/O中断发生时，需要做出调度策略。</li>
</ol>
<p>调度算法类型：</p>
<ul>
<li><strong>抢占式调度算法</strong>：选择一个进程，设定进程运行时间的最大值，当该时间已过，进程将会被挂起。</li>
<li><strong>非抢占式调度算法</strong>：与抢占式算法不同，进程获得CPU之后将会一直占有直到遇到阻塞或者进程运行结束。</li>
</ul>
<h4 id="调度算法分类"><a href="#调度算法分类" class="headerlink" title="调度算法分类"></a>调度算法分类</h4><p>根据应用场景的不同，需要设定不同的调度算法以满足用户的需求。典型的应用场景：</p>
<ul>
<li>批处理：用户不需要频繁的从系统中得到反馈。</li>
<li>交互式：交互式更加强调与用户的交互。</li>
<li>实时：强调实时得到系统的响应。</li>
</ul>
<p>上述三种场景中，场景已经决定了何种调度算法更加适合，显然：</p>
<ul>
<li>批处理更加适合非抢占式的调度算法。</li>
<li>交互式更加适合抢占式的调度算法。避免一个进程霸占CPU而不为其他进程服务。</li>
<li>实时系统:</li>
</ul>
<h4 id="调度算法的目标"><a href="#调度算法的目标" class="headerlink" title="调度算法的目标"></a>调度算法的目标</h4><p>共同目标：</p>
<ul>
<li>公平：给每个进程公平的CPU时间</li>
<li>策略强制执行：保证规定的策略被强制执行</li>
<li>平衡：保持系统中的所有资源都在运行</li>
</ul>
<p>批处理系统：</p>
<ul>
<li>吞吐量：单位时间的最大作业数</li>
<li>周转时间：一个批处理作业从提交到作业完成时刻的统计平均时间。越小越好</li>
<li>CPU利用率：保持CPU忙碌，CPU利用率并不能有效的衡量效率，最终要参考的参数还是吞吐量和周转时间</li>
<li><code>吞吐量和周转时间并不是相互关联的，获取更大的吞吐量并不一定就有最小的周转时间。短作业和长作业组合，总是调度短作业可以获得更好的吞吐量，但是长作业根本运行不了，平均周转时间很大。</code></li>
</ul>
<p>交互式系统：</p>
<ul>
<li>满足截止时间：避免丢失数据</li>
<li>可预测性：多媒体中媒体文件的品质降低的避免。</li>
<li><code>交互式系统，特别是媒体应用中，更加强调可预测性</code></li>
</ul>
<h3 id="批处理调度方案"><a href="#批处理调度方案" class="headerlink" title="批处理调度方案"></a>批处理调度方案</h3><ul>
<li><strong>先来先服务</strong>：按照进程队列对进程进行服务。</li>
<li><strong>最短作业优先</strong>：短作业优先服务</li>
<li><strong>最短剩余时间优先</strong>：比较当前短作业与正在运行的进程的剩余时间，选择短的进行读物。</li>
</ul>
<h3 id="交互式调度算法"><a href="#交互式调度算法" class="headerlink" title="交互式调度算法"></a>交互式调度算法</h3><p><strong>轮转调度</strong>：每个进程分配时间片，在时间片内拥有CPU执行，时间片结束程序状态或者结束或者阻塞挂起。轮转调度的关键技术：时间片的确定，首先时间片短，进程切换将占用更多的CPU时间，效率低下，时间片长，类似于非抢占式，用户响应迟迟未得。</p>
<p><strong>优先级调度</strong>：每个进程拥有一个优先级数，进程调度更具进程的优先级高低来选择进程，为了增加进程之间的公平性，进程的优先级应该是一个动态变化的。随着时间处于等待的进程的优先级应该不断增加，这样提高进程被调度执行的机会。也可以设置时间片，当时间片到达时，次优先级的进程获得调度执行的机会。优先级的赋予方式可以是静态的也可以是动态的。</p>
<p><strong>多级队列</strong>：进程在不断的切换中获得更多的时间片。 假如一个进程需要100个时间片，初始分得1个时间片，下一次将获得2个时间片，依次4，8，16，32…….。随着有进程优先级的不断降低，它的运行频率逐渐放慢，为短作业进程让出CPU。</p>
<p><strong>最短优点进程</strong>：类似于批处理系统的短作业优先算法。短进程如何获取：可以根据过去的行为做预测。</p>
<p><strong>保证调度</strong>：向用户做出明确的性能保证。一种简单的实现方式：根据当前用户的数量来分配CPU。</p>
<p><strong>彩票调度</strong>：基本思想就是为进程提供各种系统资源的彩票，一旦需要做出决策的时候，就随机抽出一张彩票，拥有该彩票的进程获得该资源。然后进程之间还是存在相对平等的问题，可以增加重要进程的额外彩票。</p>
<p><strong>公平分享调度</strong>：根据用户的进程数量来分配CPU资源。实现用户之间的相对公平，与保证调度不一样，这样分配的标准是以用户的进程数量来分配的。</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>问题引入：若干个进程中存在多个线程。分为用户级线程和内核级线程。<br><strong>用户级线程调度</strong>：</p>
<ul>
<li>内核不知道用户线程的情况，会选取一个用户进程进行执行，用户线程调度程序选取其中一个线程执行。</li>
<li>多个线程之间不存在时钟中断，可以运行任何时间长度，如果该线程用完整个进程的时间片，内核将会选取下一个进程执行。</li>
<li>下一次该进程分到时间片，将继续执行之前执行的线程，直到该线程完成其工作。</li>
<li>也就是说在进程时间片足够的情况下，进程内的线程可实现线程调度，从实用的角度讲，其中轮转调度和优先级调度更多的用于线程调度。</li>
</ul>
<p><strong>内核级线程调度</strong>：</p>
<ul>
<li>与用户级线程相比，内核级线程调度需要运行更多的指令，需要切换上下文环境，修改内存映像，使告诉缓存失效，从而引起若干数量级的延迟。</li>
<li>与用户级线程相比，内核级线程阻塞在I/O上不需要像用户进程一样将整个进程挂起。</li>
<li>进程间的线程相互切换的开销大于进程内的线程切换。</li>
</ul>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>分层存储器体系中，内存处于较高速度的层次。存储管理器是操作系统中管理分层存储器体系的部分。记录内存的使用情况，空闲还是正在使用，进程的内存分配和进程的内存释放的问题。</p>
<h2 id="无存储器抽象"><a href="#无存储器抽象" class="headerlink" title="无存储器抽象"></a>无存储器抽象</h2><p>最简单的存储抽象就是没有抽象，直接使用存储器的物理地址。存在的问题：程序运行基于真实的物理地址，多道程序运行容易造成内存地址的冲突。关于多道程序运行的内存冲突解决方案：设置内存地址的保护键，只有当进程访问的内存的保护键匹配时才能正确执行，否则将会被系统捕获该错误。</p>
<h2 id="存储器抽象：地址空间"><a href="#存储器抽象：地址空间" class="headerlink" title="存储器抽象：地址空间"></a>存储器抽象：地址空间</h2><p>为了使多道程序同时处于内存中且不相互影响，需要解决两个问题：</p>
<ul>
<li>保护</li>
<li>重定位</li>
</ul>
<p>问题解决方案：地址空间</p>
<p><strong>地址空间</strong>：</p>
<p>地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间，各个进程之间的地址空间相互独立。</p>
<p><strong>基址寄存器与界限寄存器</strong>：</p>
<p>通过基址寄存器与地址空间的运算以及界限寄存器检查地址的合法性这样提供多道程序的独立性。该方法存在的缺陷是：每次进行重定位的时候都需要进行加法运算以及地址合法性的检查。</p>
<p><strong>交换技术</strong>：</p>
<p>由于内存空间的有限性，加上系统程序较多，通常内存无法满足多道程序的运行。解决方案：</p>
<ul>
<li>将运行一段时间的进程返回磁盘保存，释放出内存提供给其他的进程使用，该技术叫做<strong>交换技术</strong>。</li>
<li>通过<strong>虚拟内存</strong>甚至可以使程序的一部分载入内存运行。</li>
</ul>
<p>交换技术产生的新的问题：划分出<strong>内存空闲区</strong>。解决方案：</p>
<ul>
<li>通过将每个程序向下移动，尽可能使得空闲区集中，该方法叫做<strong>内存紧缩</strong>。</li>
</ul>
<p>问题：进程的内存空间通常是动态变化的。解决方案：</p>
<ul>
<li>设置可变的内存空间，供程序的空间动态变化。通常的方式是将程序划分为三个段：代码段、数据段、堆栈段。在数据段和堆栈段之间留足空间供供动态增长。</li>
</ul>
<p><strong>空闲内存管理</strong>：</p>
<p>动态分配内存引入问题：追踪内存的使用情况。解决方案：</p>
<ul>
<li>位图</li>
<li>空闲区链表</li>
</ul>
<p><strong>位图</strong>：用一位记录一个分配单元的空闲状态，比如4字节作为一个分配单位，那么32位则需要一个位来记录。位图的缺陷：程序进行内存分配时，需要寻找位图中连续的0空间，相对较为耗时。<br><strong>空闲区链表</strong>：根据内存的使用情况，记录内存按地址顺序每一块的使用情况。这样就构成一个链表。链表中节点记录三个重要的元素：<strong>块使用情况（进程占用还是空闲）</strong>、<strong>块首地址</strong>、<strong>块长度</strong>。进程释放内存后的空闲区的合并：进程释放内存之后，该块的状态需要更新为空闲，如果该节点前后节点存在空闲块，则需要将他们进行合并，组成更大的空闲块。内存分配：在空闲区链表中寻找一块合适的空闲块作为程序分配的地址。<br>内存分配的算法有如下几种：</p>
<ol>
<li>首次适配：检索空闲链表，将第一块适合分配的内存块作为分配的目标。</li>
<li>下次适配：每次检索时，记录适配的位置，下次检索时不是从表头开始，而是从上次记录的位置开始。</li>
<li>最佳适配：检索空闲表，寻找最佳的块进行分配，该算法貌似很好，其实产生更多的碎片化的内存，造成内存的浪费。</li>
<li>最差适配：与最佳适配相反，同样该算法也不是一个好主意。</li>
</ol>
<p><strong>空闲区链表的改进</strong>：分别维护进程和空闲区各自独立的链表。则空闲区链表中内存分配的四种算法的性能将会提高。代价就是复杂度增加和内存释放的速度变慢。通过对空闲块的大小进行排序组成链表，在进行最佳适配的时候，时间复杂度将减小。<strong>快速适配</strong>：维护一个常用大小的空闲内存块的链表。</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>使用基地址寄存器和界限寄存器来创建抽象地址空间，引入新的问题：<strong>管理软件的膨胀</strong>。发展带来的问题就是程序设计越来越大，使用交换技术来解决是其中的一种方案，但是相对较为耗时。问题的解决：<strong>程序分割</strong>。成为<strong>覆盖(<code>overlay</code>)</strong>.虚拟内存的基本思路：每个程序拥有自己的地址空间，这个空间被分割成多个块，每一个块成为<strong>页面</strong>或者<strong>页</strong>，每一个页面的地址连续。（一部分页面加载到内存即可运行程序）</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>分页机制中，真实的物理地址通过<strong>索引、基地址寄存器、段寄存器和其他方式</strong>产生。虚拟地址空间被送入<strong>内存管理单元</strong>（<code>Memory Management Unit</code>,<code>MMU</code>)，该部件将虚拟地址映射成物理地址。下图指出MMU的位置与功能。</p>
<img src="/blog/2021/05/19/OS/MMU%E5%8A%9F%E8%83%BD%E4%B8%8E%E4%BD%8D%E7%BD%AE.PNG" class>

<p>虚拟地址空间按照固定的大小划分成被称为页面的若干单元，在物理内存中对应的单元称作<strong>页框</strong>。RAM与磁盘之间的交换总是以整个页面为单位进行的。通常页面的大小设计也不是唯一的，用户程序与内核程序使用的页面大小就不一定相同大小。分页算法中还需要记录具体的页面是否在内存中，也就是需要一bit来记录。如果发生需要的页面不在内存中，CPU陷入到操作系统中，发生<strong>缺页中断</strong>。操作系统需要将访问的页面读到被回收的页框中，修改映射关系（页表与页框之间的映射），然后重新启动引起陷阱的指令。</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>虚拟地址空间的映射一种简单的是实现方案就是：虚拟地址被划分为虚拟页号和偏移量。将虚拟号与页框号进行对应，然后将页框号与偏移量进行拼接得到物理地址。页表项的结构：</p>
<img src="/blog/2021/05/19/OS/%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84.PNG" class>

<p>结构介绍：</p>
<ul>
<li><strong>保护</strong>：表示该页面可以被什么类型访问，简单的访问类型用一个bit表示即可，采用unix的访问模式可利用三个bit来表示，分别表示读权限，写权限和执行权限。</li>
<li><strong>修改</strong>：当该页面被修改，也就是说该页面的数据为脏数据时，需要将其写回磁盘，如果页面没有任何变动，那么在回收的时候就直接舍弃掉即可。</li>
<li><strong>访问</strong>：当系统访问该页面时，将会记录其访问记录，以便于在进行页面置换的时候提供算法的原数据。根据经常访问原理，被访问过的页面再次被访问的概率更大。</li>
<li><strong>在/不在</strong>：记录该页面是否在内存中。</li>
</ul>
<h3 id="加速分页过程"><a href="#加速分页过程" class="headerlink" title="加速分页过程"></a>加速分页过程</h3><p>分页系统需要解决两个问题：</p>
<ul>
<li>虚拟地址的映射越快越好。</li>
<li>虚拟地址空间越大，页表越大。</li>
</ul>
<p>设计大而快速的映射，可以通过硬件的方式实现，通过专用的映射结构来实现虚拟地址的映射。代价：映射表越大，代价越大。如果将这个页表放入内存中，那么在进行页表检索的时候，访问内存的消耗较大，速度较慢。</p>
<p><strong>转换检测缓冲区</strong>：</p>
<p>分页机制引起的问题：由于分页机制存在，查找指令需要多次访问指令，而访问内存是一个很耗时的过程。程序特点：大多数程序总是对少量的页面进行多次的访问。解决方案：为计算机设置一个小型的硬件设备，将虚拟地址直接映射到物理地址，不需要再访问页表。该设备叫做<strong>转换检测缓冲区</strong>（<code>Translation Lookaside Buffer</code>,TLB).又称相联存储器或者快表。该硬件通常在MMU中。下面是一个TLB的加速分页表</p>
<img src="/blog/2021/05/19/OS/TLB%E5%88%86%E9%A1%B5%E5%8A%A0%E9%80%9F%E8%A1%A8.PNG" class>

<p><strong>软件管理TLB</strong>：</p>
<p>原始的TLB管理：TLB的管理和TLB的失效处理完全由MMU硬件实现。只有在内存中没有找到响应的页面时，才会陷入到操作系统中。软件管理TLB：TLB表项被操作系统显式的装载，当发生TLB失效时，不由MMU处理，而是生成一个TLB失效并交由操作系统解决。系统首先找到该页面，然后从TLB中删除一个项，接着装载一个新的项，最后执行先前出错的命令。软件管理TLB的问题：当页表不在TLB中发生TLB失效，处理过程产生额外的TLB失效。软件管理TLB问题的解决：在内存固定位置维护一个大的TLB表项的软件高速缓存来减少TLB失效。TLB失效的类别：</p>
<ul>
<li>软失效：当一个页面在内存中却不在TLB中，该失效叫做软失效。</li>
<li>硬失效：一个页面既不在TLB中也不在内存中，该失效叫做硬失效。</li>
</ul>
<p>软失效通常也叫做次要缺页错误，硬失效叫做严重缺页错误，如果程序访问一个非法地址，则发生段错误。</p>
<h3 id="针对大内存的页表"><a href="#针对大内存的页表" class="headerlink" title="针对大内存的页表"></a>针对大内存的页表</h3><h4 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h4><p>通过增加映射的级数，也就是多级映射可以解决大内存映射表的问题。多级映射避免把全部页表一直保存在内存中。特别是那些从不需要使用的表就不应该保存在内存中。</p>
<h4 id="倒排页表"><a href="#倒排页表" class="headerlink" title="倒排页表"></a>倒排页表</h4><p>内存中每个页框对应一个表项，而不是每个虚拟页面对应一个表项。问题：虚拟地址到物理地址的映射变得很困难。每次都需要搜索整个倒排页表寻找（进程，虚拟页表），而该过程在内存中运行，显然不是加速的一种方法。使用TLB记录频繁使用的页面，地址转换变得快速。</p>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>发生缺页终端，操作系统需要从内存中寻找一个页面将其置换出内存，为新的调入页面腾出空间。如果该页面在内存中被修改过，则需要更新磁盘的内容，如果没有任何修改表示磁盘的数据是最新的，直接用新调入的页面覆盖即可。页面置换会随着程序的执行一直发生，如何选择页面进行置换使得置换发生的次数更少则是关键核心问题。该问题由页面置换算法来解决。</p>
<h3 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h3><p>根据程序的数据的局部性原理，当一条指令被访问到，那么该指令后面的数条指令很可能会被访问到，每个页面可以用在该页面被首次访问所要执行的指令数量作为标记。最优页面置换算法规定应该置换标记最大的页面。如果一个页面在一个数目指令条数下不会被访问到， 从中选取最小的不会被访问的页面进行置换。<br>该算法无法实现：无法了解页面的指令什么时候会被执行。某种情况下可以实现：第一次执行程序记录页面访问时间。</p>
<h3 id="最近未使用页面置换算法"><a href="#最近未使用页面置换算法" class="headerlink" title="最近未使用页面置换算法"></a>最近未使用页面置换算法</h3><p>大部分具有虚拟内存的计算机中，系统为每一个页面设置两个状态。当页面被访问时设置R 位，当页面被写入时设置M位。这些位包含在每个页表中，通过硬件来设置这些位。可以用R位和M位来实现简单的页面置换算法：当启动一个进程时，它的所有页面的两个位都由操作系统设置成0，R位被定期清零，以区别最近没有访问的页面和被访问页面。当发生缺页中断时，操作系统检查所有页面并根据他们当前的R位和M位的值，把他们分为四类：</p>
<ul>
<li>第0类：没有被访问，没有被修改。</li>
<li>第1类：没有被访问，已经修改。</li>
<li>第2类：已被访问，未被修改。</li>
<li>第3类：已被访问，已被修改。</li>
</ul>
<p>上述的第一类，在第三类的页面在R位被时钟清零后就变成第一类。时钟不清零M位的原因：在决定一个页面需要写回磁盘时将要使用M位的信息。最近未使用算法（<code>Not Recently Used</code>,<strong>NRU</strong>)随机地从此类编号最小的非空类中选取一个页面淘汰。<br>对于最近未使用算法的理解：在最近一个时钟滴答中，淘汰一个没有被访问的已被修改的页面要比淘汰一个频繁使用的干净页面好。最近未使用的优点：易于理解，有效实现，性能足够使用。</p>
<h3 id="先进先出页面置换算法"><a href="#先进先出页面置换算法" class="headerlink" title="先进先出页面置换算法"></a>先进先出页面置换算法</h3><p>操作系统维护一个所有当前在内存中的页面的链表，最新进入的页面放在表尾，最早进入的页面放在表头，发生缺页中断时，从表头中删除第一个页面，然后在表尾插入新的页面。该算法的问题：经常被访问的页面被置换出，重复的进行页面置换。所以纯粹的FIFO算法很少使用。</p>
<h3 id="第二次机会页面置换算法"><a href="#第二次机会页面置换算法" class="headerlink" title="第二次机会页面置换算法"></a>第二次机会页面置换算法</h3><p>对FIFO算法进行适当的修改：检查最老页面的R位。如果R位是0，那么该页面表示既老又没有被使用，理当被置换掉，如果是1，将R置为0，并把该页面放到链表的尾端，修改它的装入时间使得其像新的页面被装入。第二次机会页面置换算法就是在寻找一个在最近时间间隔内没有被访问的页面。如果所有的页面都被访问那么就是简单的FIFO算法。算法缺点：链表中宏移动页面的操作较多，性能相对有影响。</p>
<h3 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h3><p>把所有的页面保存在一个类似于钟面的环形链表中，一个表指针指向最来的页面。如下图：</p>
<img src="/blog/2021/05/19/OS/%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.PNG" class>

<p>当发生缺页中断时，算法首先检查表指针指向的页面，如果R位位0直接淘汰，并将新的页面插入到该位置，并将表指针向前移动一个位置。如果R位位1，那么将R位清零，表指针向前移动一位。重复这个位置直到找到一个R位为0的页面为止。<strong>第二次机会页面置算法与时钟页面置换算法对比</strong>：显然，从数据操作上面来看，第二次机会是通过不断移动页面实现页面的置换，而时钟页面置换算法是通过移动指针来实现页面的置换，这里明显知道指针的移动性能相对较高。</p>
<h3 id="最近最少使用页面置换算法"><a href="#最近最少使用页面置换算法" class="headerlink" title="最近最少使用页面置换算法"></a>最近最少使用页面置换算法</h3><p>最近最少使用算法（<code>Least Recently Used</code>,<strong>LRU</strong>)的策略是：在缺页中断发生时，置换未使用时间最长的页面。LRU的实现：在内存中维护ige所有页面的链表，最近最多使用的在表头，最近最少使用的页面在表尾。每次访问内存需要更新链表，维护链表的性质（相对较为耗费资源）。</p>
<h3 id="用软件模拟LRU"><a href="#用软件模拟LRU" class="headerlink" title="用软件模拟LRU"></a>用软件模拟LRU</h3><p>算法将每个页面与一个计数器绑定，初始值为0.每次操作系统扫描内存将页面的R位加到计数器中，该计数器反应该页面被访问的频繁程度。发生缺页中断时，将计数器数值最小的页面置换出去。</p>
<h3 id="工作集页面置换页面"><a href="#工作集页面置换页面" class="headerlink" title="工作集页面置换页面"></a>工作集页面置换页面</h3><ul>
<li>请求调页：当页面需要时才调入内存，而不是预先装入。</li>
<li>算法的理论基础：程序的局部性原理，实现调入指令的一个集合，该集合内的指令很可能会被马上被访问。</li>
<li>工作集（<code>defenition</code>):一个进程当前正在使用的页面的集合。</li>
</ul>
<p>工作集模型：跟踪进程的工作集，确保让进程运行以前，它的工作集就已经存在在内存中。尽量减少缺页中断。</p>
<h3 id="工作集时钟页面置换算法"><a href="#工作集时钟页面置换算法" class="headerlink" title="工作集时钟页面置换算法"></a>工作集时钟页面置换算法</h3><p>工作集时钟页面置换算法的数据结构如下：</p>
<img src="/blog/2021/05/19/OS/%E5%B7%A5%E4%BD%9C%E9%9B%86%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.PNG" class>

<p>装入第一个页面之后，把它加入到该表中，随着表的加入，形成一个环，每个表项包括基本的工作集上次使用的时间、R位、M位。</p>
<p>算法过程：</p>
<ul>
<li>发生缺页中断时，首先检查指针指向的页面，如果R位被置为1，该页面在当前时钟就被使用过，那么该页面不适合被淘汰。然后将其R位置为0，指针指向下一个页面，并重复该算法。</li>
<li>重复该算法找到一个页面R位为0，而如果M为1，表示其被修改过，那么该页面不能被直接替换。</li>
</ul>
<h3 id="页面置换算法总结"><a href="#页面置换算法总结" class="headerlink" title="页面置换算法总结"></a>页面置换算法总结</h3><p>几种页面置换算法的总结如下：</p>
<img src="/blog/2021/05/19/OS/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.PNG" class>

<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>对于很多问题来说，有两个或者多个独立的地址空间可能比只有一个要好很多。比如存在一个程序多种动态增长的表，如果表的地址空间是独立的，那么在动态增长的时候就很方便。解决办法：在机器上提供多个相互独立的成为<strong>段</strong>的地址空间。每个段由一个从0开始到最大线性地址构成。根据实际情况，每个段的实际长度可以不同，</p>
<p>分段存储管理的优点：</p>
<ul>
<li>程序编译的地址不需要时刻变动。</li>
<li>有助于进程之间共享过程和数据，最常见的例子就是：共享库</li>
</ul>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>长期存储的信息三个基本的要求：</p>
<ul>
<li>能够存储大量的信息</li>
<li>使用信息的进程终止时，信息仍然存在</li>
<li>必须能使多个进程并发访问有关信息。</li>
</ul>
<p>文件是进程创建的信息逻辑单元。一个磁盘一般含有几千甚至几百万个文件，每个文件是独立于其他文件的，唯一不同的是文件是对磁盘的建模，而非对RAM的建模。所以，从本质上看，文件就是一个地址空间。文件的最大的特点就是持久化。文件是操作系统管理的对象，操作系统主要对文件构造、命名、访问、使用、保护、实现和管理。通过文件系统来抽象对文件的相关操作。</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>扩展名的作用：</p>
<ul>
<li>区分文件类别。</li>
<li>编译器在进行编译时，使得文件分辨较为容易。</li>
</ul>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><ul>
<li>字节流序列：无结构文件类型，Windows与unix都采用这种方式。</li>
<li>定长序列。</li>
<li>树型结构。</li>
</ul>
<h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><ul>
<li>文件命名</li>
<li>文件操作</li>
<li>文件存储</li>
<li>磁盘管理</li>
</ul>
<h3 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h3><p>文件系统存放在磁盘中，多数磁盘被划分为一个或者多个分区，每个分区中有一个独立的文件系统。磁盘的0号扇区称为<strong>主引导记录</strong>（<code>Master Boot Record</code>),用来引导计算机。主引导记录后面是分区表，分区表记录每个分区的起始与终止地址。通常每个分区有一个引导块，即便没有对应的引导程序。文件系统结构如下：</p>
<img src="/blog/2021/05/19/OS/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80.PNG" class>

<p><strong>超级块</strong>：记录文件的关键参数，当文件首次被加载时，超级快会被读入内存。关键参数包括：确定文件类型的魔数，文件系统中块的数量和其他管理信息。</p>
<p><strong>空闲块</strong>：利用位图或者指针列表指定空闲块的位置。</p>
<p><strong>i节点</strong>：指定文件的磁盘位置以及文件大小等属性。</p>
<h3 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h3><p>文件系统如何组织磁盘块</p>
<ol>
<li>连续分配：一次性写多次读取的应用，比如CD，DVD等文件设备。</li>
<li>链表分配：实现思路：为每个文件构造一个磁盘块链表。块中存放下一块的位置信息以及块的文件信息。缺陷：随机读取的性能下降，链表指针占用一定的磁盘空间。</li>
<li>采用内存中的表进行链表分配：将磁盘块的指针字存放到内存表中，通过内存中的表记录文件磁盘块的相对位置，该表格称作：<strong>文件分配表</strong>。</li>
<li>I节点：i节点记录文件的属性以及占用的磁盘块的地址。</li>
</ol>
<h1 id="虚拟化与云"><a href="#虚拟化与云" class="headerlink" title="虚拟化与云"></a>虚拟化与云</h1><p>多计算机环境下，可以使用多计算机实现负载均衡与安全性的问题。安全性：多计算机情况下，将事务分别在不同的计算机上完成，不因为一个计算机宕机而影响整个系统的执行。多计算机解决不同操作系统在一个集群中运行的情况。为了运行多种操作系统的解决方案之二：<strong>虚拟化</strong>。虚拟化的主要思想：<strong>虚拟监控程序</strong>(<code>Virtual Machine Monitor</code>）在同一个物理机器上创建出多个虚拟机的假象，VMM又称作<strong>虚拟机管理程序</strong>。<br>虚拟机之间运行时相互独立的，互不影响，不会因为其中一个虚拟机运行出错影响其他虚拟机的运行。虚拟机通过隔离的机制提供安全性的保证。虚拟机的优点：</p>
<ul>
<li>提供强隔离性。</li>
<li>设置检查点与虚拟机迁移比普通操作系统上运行的迁移更加方便。</li>
<li>可用于协助软件开发。</li>
</ul>
<p>虚拟化目前最重要的用途：<strong>云</strong>。将计算和存储需求打包给数据中心。</p>
<h2 id="虚拟化的必要条件"><a href="#虚拟化的必要条件" class="headerlink" title="虚拟化的必要条件"></a>虚拟化的必要条件</h2><p>为了使得虚拟机像真实的机器那样正常启动，支持任意操作系统，虚拟机管理程序需要在以下三个维度表现良好：</p>
<ul>
<li><strong>安全性</strong>：虚拟机管理程序应该完全掌握虚拟资源。</li>
<li><strong>保真性</strong>：程序在虚拟机上的执行行为应该与在裸机上相同。</li>
<li><strong>高效性</strong>：虚拟机中运行的大部分代码不应该受到虚拟机管理程序的干涉。</li>
</ul>
<p>关于保真性，存在问题：每个包含内核态和用户态的CPU都有一个特殊的指令集，其中的指令在用户态和内核态的指令行为不同。</p>
<ul>
<li>敏感指令：进行I/O操作和修改MMU设置的指令。</li>
<li>特权指令：在用户态执行会陷入。</li>
</ul>
<p>存在的问题：</p>
<ul>
<li>问题一：敏感指令在用户态未能陷入。</li>
<li>问题二：用户态读取敏感状态而不造成陷入的指令（该类指令用户态和内核态的执行行为相同），操作系统无法确认自己的态从而做出错误的决策。</li>
</ul>
<p>通常当敏感指令属于特权指令的子集时，可进行虚拟化。也就是说用户态想要完成不应该在用户态完成的事情，硬件必须陷入。<br>问题解决：</p>
<ul>
<li>通过引入**<code>VT</code>**技术（<code>Virtual Technology</code>),也就是在CPU中引入虚拟化支持。</li>
<li>VT技术的基本思想：创建可以运行虚拟机的容器，客户操作系统在容器中启动并持续运行，直到出发异常并陷入虚拟机管理程序。会造成陷入的指令集合由虚拟机管理程序设置的硬件位图控制。</li>
</ul>
<p><strong>二进制翻译</strong>：</p>
<p>虚拟机管理程序并未真正运行原始的客户操作系统，虚拟机管理程序在运行中改写部分代码，将有问题的不知零替换成了安全的指令序列，模拟元指令的功能。上述的指令执行结果必须限制在虚拟机内部，不能影响其他虚拟机火鹤虚拟机管理程序自身。因此，一条不安全的I/O指令会被替换为一个陷入操作，经过安全性检查之后，执行等价的指令并返回结果。</p>
<p><strong>半虚拟化</strong>：</p>
<p>提供一层类似物理机器的软件接口，显示暴露出自身是一个虚拟化的环境。提供一组虚拟化调用，允许用户向虚拟机发起显式的请求，类似于系统功能调用为用户程序提供服务一样。</p>
<h2 id="第一类和第二类虚拟化管理程序"><a href="#第一类和第二类虚拟化管理程序" class="headerlink" title="第一类和第二类虚拟化管理程序"></a>第一类和第二类虚拟化管理程序</h2><img src="/blog/2021/05/19/OS/%E7%AC%AC%E4%B8%80%E7%B1%BB%E4%B8%8E%E7%AC%AC%E4%BA%8C%E7%B1%BB%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F.PNG" class>

<p><strong>第一类虚拟机管理程序</strong></p>
<p>上图中，第一类虚拟机管理程序，从技术上讲，第一类虚拟机管理程序就像一个操作系统，其是唯一一个运行在最高特权级的程序。其工作是支持真实硬件的多个虚拟机拷贝，类似于普通操作系统支持的进程。</p>
<p><strong>第二类虚拟机管理程序</strong></p>
<p>第二类虚拟机管理程序是在宿主操作系统上运行的进程。当然，第二类虚拟机管理程序仍然伪装成具有CPU和各种设备的完整计算机。第二类虚拟机管理程序也称作<strong>托管虚拟机管理程序</strong>，依赖于宿主操作系统，运行客户操作系统。</p>
<h2 id="高效虚拟化技术"><a href="#高效虚拟化技术" class="headerlink" title="高效虚拟化技术"></a>高效虚拟化技术</h2><img src="/blog/2021/05/19/OS/%E8%99%9A%E6%8B%9F%E5%86%85%E6%A0%B8%E6%80%81%E6%9E%B6%E6%9E%84%E5%9B%BE.PNG" class>

<p>虚拟机作为用户态进程运行，不允许执行敏感指令，虚拟机上客户操作系统认为自己运行在内核态，从图中我们知道，我们称之为<strong>虚拟内核态</strong>。虚拟机中同样也运行真实的用户态进程。<br>虚拟机被分为虚拟机用户态与虚拟内核态，两个同属于真实的用户态。只有虚拟机管理程序运行在内核态。</p>
<h2 id="半虚拟化与全虚拟化的对比"><a href="#半虚拟化与全虚拟化的对比" class="headerlink" title="半虚拟化与全虚拟化的对比"></a>半虚拟化与全虚拟化的对比</h2>

<ul>
<li>全虚拟化的管理程序，用户程序在执行敏感指令通过陷入的方式进入内核态。</li>
<li>半虚拟化的管理程序，用户程序在执行通过虚拟化调用陷入。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/OS/" rel="tag"># OS</a>
              <a href="/blog/tags/Modern-OS/" rel="tag"># Modern OS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/2021/05/19/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/" rel="prev" title="虚拟机网络连接">
      <i class="fa fa-chevron-left"></i> 虚拟机网络连接
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/2021/05/19/git/" rel="next" title="Git-base">
      Git-base <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8B%B1%E7%89%B9%E7%BA%B3%E9%9B%84%E8%80%90%E5%B0%94%E4%B8%80%E5%AE%9A%E8%A6%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.</span> <span class="nav-text">英特纳雄耐尔一定要实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%AE%BA"><span class="nav-number">2.</span> <span class="nav-text">概论</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">进程与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">3.3.</span> <span class="nav-text">进程间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6"><span class="nav-number">3.4.</span> <span class="nav-text">调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%80%E4%BB%8B"><span class="nav-number">3.4.1.</span> <span class="nav-text">调度简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%A1%8C%E4%B8%BA"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">进程行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E6%97%B6%E6%9C%BA"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">调度时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB"><span class="nav-number">3.4.1.3.</span> <span class="nav-text">调度算法分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="nav-number">3.4.1.4.</span> <span class="nav-text">调度算法的目标</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E8%B0%83%E5%BA%A6%E6%96%B9%E6%A1%88"><span class="nav-number">3.4.2.</span> <span class="nav-text">批处理调度方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.3.</span> <span class="nav-text">交互式调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">3.4.4.</span> <span class="nav-text">线程调度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E5%AD%98%E5%82%A8%E5%99%A8%E6%8A%BD%E8%B1%A1"><span class="nav-number">4.1.</span> <span class="nav-text">无存储器抽象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E6%8A%BD%E8%B1%A1%EF%BC%9A%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">4.2.</span> <span class="nav-text">存储器抽象：地址空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">4.3.</span> <span class="nav-text">虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5"><span class="nav-number">4.3.1.</span> <span class="nav-text">分页</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8"><span class="nav-number">4.3.2.</span> <span class="nav-text">页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E9%80%9F%E5%88%86%E9%A1%B5%E8%BF%87%E7%A8%8B"><span class="nav-number">4.3.3.</span> <span class="nav-text">加速分页过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%92%88%E5%AF%B9%E5%A4%A7%E5%86%85%E5%AD%98%E7%9A%84%E9%A1%B5%E8%A1%A8"><span class="nav-number">4.3.4.</span> <span class="nav-text">针对大内存的页表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">4.3.4.1.</span> <span class="nav-text">多级页表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%92%E6%8E%92%E9%A1%B5%E8%A1%A8"><span class="nav-number">4.3.4.2.</span> <span class="nav-text">倒排页表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.</span> <span class="nav-text">页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.1.</span> <span class="nav-text">最优页面置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%AA%E4%BD%BF%E7%94%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.2.</span> <span class="nav-text">最近未使用页面置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.3.</span> <span class="nav-text">先进先出页面置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%9C%BA%E4%BC%9A%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.4.</span> <span class="nav-text">第二次机会页面置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.5.</span> <span class="nav-text">时钟页面置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.6.</span> <span class="nav-text">最近最少使用页面置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%A8%A1%E6%8B%9FLRU"><span class="nav-number">4.4.7.</span> <span class="nav-text">用软件模拟LRU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E9%A1%B5%E9%9D%A2"><span class="nav-number">4.4.8.</span> <span class="nav-text">工作集页面置换页面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.9.</span> <span class="nav-text">工作集时钟页面置换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="nav-number">4.4.10.</span> <span class="nav-text">页面置换算法总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%AE%B5"><span class="nav-number">4.5.</span> <span class="nav-text">分段</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">5.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6"><span class="nav-number">5.1.</span> <span class="nav-text">文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D"><span class="nav-number">5.1.1.</span> <span class="nav-text">文件命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.2.</span> <span class="nav-text">文件结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.2.</span> <span class="nav-text">文件系统的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B8%83%E5%B1%80"><span class="nav-number">5.2.1.</span> <span class="nav-text">文件系统布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.2.2.</span> <span class="nav-text">文件系统实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8E%E4%BA%91"><span class="nav-number">6.</span> <span class="nav-text">虚拟化与云</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">6.1.</span> <span class="nav-text">虚拟化的必要条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%B1%BB%E5%92%8C%E7%AC%AC%E4%BA%8C%E7%B1%BB%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">6.2.</span> <span class="nav-text">第一类和第二类虚拟化管理程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E6%95%88%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="nav-number">6.3.</span> <span class="nav-text">高效虚拟化技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8A%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8E%E5%85%A8%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">6.4.</span> <span class="nav-text">半虚拟化与全虚拟化的对比</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="RockCohen"
      src="/blog/images/hugo.png">
  <p class="site-author-name" itemprop="name">RockCohen</p>
  <div class="site-description" itemprop="description">a programmer</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/rockcohen" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;rockcohen" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xluo0616@gmail.com" title="E-Mail → mailto:xluo0616@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">RockCohen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>




  















  

  

</body>
</html>
